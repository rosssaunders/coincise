# WS-OVERVIEW

# Advanced Trade WebSocket Overview

The WebSocket feed is publicly available and provides real-time market data updates for orders and trades. Two endpoints are supported in production:

- **Market Data** is our traditional feed that provides updates for both orders and trades. Most channels are now available without authentication.
- **User Order Data** provides updates for the orders of the user.



Info

**Market Data** Endpoint: `wss://advanced-trade-ws.coinbase.com`

**User Order Data** Endpoint: `wss://advanced-trade-ws-user.coinbase.com`



Tip

You can subscribe to the Heartbeats Channel, User Channel and Futures Balance Summary Channel with the User Order Data endpoint. If advanced-trade-ws-user is your primary connection, we recommend using advanced-trade-ws as a failover.

## Protocol [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#protocol "Direct link to Protocol")

The WebSocket feed uses a bidirectional protocol that encodes all messages as JSON objects. All messages have a `type` attribute that can be used to handle the message appropriately.



Tip

New message types can be added at any time. Clients are expected to ignore messages they do not support.

## Sending Messages with CDP Keys [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#sending-messages-with-cdp-keys "Direct link to Sending Messages with CDP Keys")

### Subscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#subscribing "Direct link to Subscribing")

To begin receiving feed messages, you must send a `subscribe` message to the server indicating which channel and products to receive. This message is mandatory and you are disconnected if no `subscribe` has been received within 5 seconds.

You can subscribe to multiple channels but you must send a unique subscription message for each channel.



Caution

To receive feed messages, you must send a `subscribe` message or you are disconnected in 5 seconds.

```codeBlockLines_p187
// Request
// Subscribe to ETH-USD and ETH-EUR with the level2 channel
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2",
  "jwt": "exampleJWT"
}

```

To subscribe to any channel, provide a `channel` name and `jwt`:

- `channel` name as a string. You can only subscribe to one channel per subscription message.

- `jwt` can be generated by running one of the code snippets provided in the [WebSocket Authentication page](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth). Remember that you must generate a different JWT for each websocket message sent, since the JWTs will expire after 2 minutes.

### Unsubscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#unsubscribing "Direct link to Unsubscribing")

To unsubscribe from a channel/product pair, send an `unsubscribe` message. The structure is the same as `subscribe` message. You can only unsubscribe from one channel per subscription message. You can also unsubscribe from a channel entirely by providing no product IDs.

```codeBlockLines_p187
// Request
{
  "type": "unsubscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2",
  "jwt": "exampleJWT"
}

```

You receive a `subscriptions` message as a response to an `unsubscribe` message.

## Websocket Code Samples [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#websocket-code-samples "Direct link to Websocket Code Samples")

Use the code samples to subscribe to one or more Advanced Trade WebSocket channels using CDP API Keys.

## JavaScript

## Python

```codeBlockLines_p187
// JS Example for subscribing to a channel
/* eslint-disable */
const WebSocket = require("ws");
const { sign } = require("jsonwebtoken");
const crypto = require("crypto");
const fs = require("fs");

// Derived from your Coinbase CDP API Key
//  SIGNING_KEY: the signing key provided as a part of your API key. Also called the "SECRET KEY"
//  API_KEY: the api key provided as a part of your API key. also called the "API KEY NAME"
const API_KEY = "organizations/{org_id}/apiKeys/{key_id}";
const SIGNING_KEY =
  "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

const algorithm = "ES256";

if (!SIGNING_KEY.length || !API_KEY.length) {
  throw new Error("missing mandatory environment variable(s)");
}

const CHANNEL_NAMES = {
  level2: "level2",
  user: "user",
  tickers: "ticker",
  ticker_batch: "ticker_batch",
  status: "status",
  market_trades: "market_trades",
  candles: "candles",
};

// The base URL of the API
const WS_API_URL = "wss://advanced-trade-ws.coinbase.com";

function signWithJWT(message, channel, products = []) {
  const jwt = sign(
    {
      iss: "cdp",
      nbf: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 120,
      sub: API_KEY,
    },
    SIGNING_KEY,
    {
      algorithm,
      header: {
        kid: API_KEY,
        nonce: crypto.randomBytes(16).toString("hex"),
      },
    }
  );

  return { ...message, jwt: jwt };
}

const ws = new WebSocket(WS_API_URL);

function subscribeToProducts(products, channelName, ws) {
  const message = {
    type: "subscribe",
    channel: channelName,
    product_ids: products,
  };
  const subscribeMsg = signWithJWT(message, channelName, products);
  ws.send(JSON.stringify(subscribeMsg));
}

function unsubscribeToProducts(products, channelName, ws) {
  const message = {
    type: "unsubscribe",
    channel: channelName,
    product_ids: products,
  };
  const subscribeMsg = signWithJWT(message, channelName, products);
  ws.send(JSON.stringify(subscribeMsg));
}

function onMessage(data) {
  const parsedData = JSON.parse(data);
  fs.appendFile("Output1.txt", data, (err) => {
    // In case of a error throw err.
    if (err) throw err;
  });
}

const connections = [];
let sentUnsub = false;
for (let i = 0; i < 1; i++) {
  const date1 = new Date(new Date().toUTCString());
  const ws = new WebSocket(WS_API_URL);

  ws.on("message", function (data) {
    const date2 = new Date(new Date().toUTCString());
    const diffTime = Math.abs(date2 - date1);
    if (diffTime > 5000 && !sentUnsub) {
      unsubscribeToProducts(["BTC-USD"], CHANNEL_NAMES.level2, ws);
      sentUnsub = true;
    }

    const parsedData = JSON.parse(data);
    fs.appendFile("Output1.txt", data, (err) => {
      // In case of a error throw err.
      if (err) throw err;
    });
  });

  ws.on("open", function () {
    const products = ["BTC-USD"];
    subscribeToProducts(products, CHANNEL_NAMES.level2, ws);
  });

  connections.push(ws);
}

```

```codeBlockLines_p187
# Python Example for subscribing to a channel
import time
import json
import jwt
import hashlib
import os
import websocket
import threading
from datetime import datetime, timedelta

# Derived from your Coinbase CDP API Key
# SIGNING_KEY: the signing key provided as a part of your API key. Also called the "SECRET KEY"
# API_KEY: the api key provided as a part of your API key. also called the "API KEY NAME"
API_KEY = "organizations/{org_id}/apiKeys/{key_id}"
SIGNING_KEY = """-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
-----END EC PRIVATE KEY-----"""

ALGORITHM = "ES256"

if not SIGNING_KEY or not API_KEY:
    raise ValueError("Missing mandatory environment variable(s)")

CHANNEL_NAMES = {
    "level2": "level2",
    "user": "user",
    "tickers": "ticker",
    "ticker_batch": "ticker_batch",
    "status": "status",
    "market_trades": "market_trades",
    "candles": "candles",
}

WS_API_URL = "wss://advanced-trade-ws.coinbase.com"

def sign_with_jwt(message, channel, products=[]):
    payload = {
        "iss": "coinbase-cloud",
        "nbf": int(time.time()),
        "exp": int(time.time()) + 120,
        "sub": API_KEY,
    }
    headers = {
        "kid": API_KEY,
        "nonce": hashlib.sha256(os.urandom(16)).hexdigest()
    }
    token = jwt.encode(payload, SIGNING_KEY, algorithm=ALGORITHM, headers=headers)
    message['jwt'] = token
    return message

def on_message(ws, message):
    data = json.loads(message)
    with open("Output1.txt", "a") as f:
        f.write(json.dumps(data) + "\n")

def subscribe_to_products(ws, products, channel_name):
    message = {
        "type": "subscribe",
        "channel": channel_name,
        "product_ids": products
    }
    signed_message = sign_with_jwt(message, channel_name, products)
    ws.send(json.dumps(signed_message))

def unsubscribe_to_products(ws, products, channel_name):
    message = {
        "type": "unsubscribe",
        "channel": channel_name,
        "product_ids": products
    }
    signed_message = sign_with_jwt(message, channel_name, products)
    ws.send(json.dumps(signed_message))

def on_open(ws):
    products = ["BTC-USD"]
    subscribe_to_products(ws, products, CHANNEL_NAMES["level2"])

def start_websocket():
    ws = websocket.WebSocketApp(WS_API_URL, on_open=on_open, on_message=on_message)
    ws.run_forever()

def main():
    ws_thread = threading.Thread(target=start_websocket)
    ws_thread.start()

    sent_unsub = False
    start_time = datetime.utcnow()

    try:
        while True:
            if (datetime.utcnow() - start_time).total_seconds() > 5 and not sent_unsub:
                # Unsubscribe after 5 seconds
                ws = websocket.create_connection(WS_API_URL)
                unsubscribe_to_products(ws, ["BTC-USD"], CHANNEL_NAMES["level2"])
                ws.close()
                sent_unsub = True
            time.sleep(1)
    except Exception as e:
        print(f"Exception: {e}")

if __name__ == "__main__":
    main()

```

## Sending Messages without API Keys [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#sending-messages-without-api-keys "Direct link to Sending Messages without API Keys")

### Subscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#subscribing-1 "Direct link to Subscribing")

```codeBlockLines_p187
// Request
// Subscribe to ETH-USD and ETH-EUR with the level2 channel
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2"
}

```

### Unsubscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#unsubscribing-1 "Direct link to Unsubscribing")

```codeBlockLines_p187
// Request
{
  "type": "unsubscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2"
}

```

## Sequence Numbers [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#sequence-numbers "Direct link to Sequence Numbers")

Most feed messages contain a sequence number. Sequence numbers are increasing integer values for each product, with each new message being exactly one sequence number greater than the one before it.

Sequence numbers that are _greater than one integer value_ from the previous number indicate that a message has been dropped. Sequence numbers that are _less_ than the previous number can be ignored or represent a message that has arrived out of order.

In either situation you may need to perform logic to make sure your system is in the correct state.



Caution

Even though a WebSocket connection is over TCP, the WebSocket servers receive market data in a manner that can result in dropped messages. Your feed consumer should be designed to handle sequence gaps and out of order messages, or should use channels that guarantee delivery of messages.



Tip

To guarantee that messages are delivered and your order book is in sync, consider using the [level2 channel](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#level2-channel).

**See Also:**

- [WebSocket Channels](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels)
- [WebSocket Rate Limits](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-rate-limits)

# WS-SETUP-GUIDE

# Advanced Trade WebSockets: Setup, Authentication, and Subscriptions

## 1. Introduction [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#1-introduction "Direct link to 1. Introduction")

This guide provides a comprehensive overview of setting up Coinbase Advanced Trade WebSockets, including essential steps for authentication and managing subscriptions. Coinbase’s Advanced Trade WebSocket API enables real-time access to market data and user-specific order information, empowering developers to build robust trading applications and monitoring tools. In this first part, you’ll learn how to establish WebSocket connections, authenticate using JWT tokens, and efficiently subscribe to key channels, such as market data and user-specific channels. With this foundational knowledge, you’ll be prepared to integrate the WebSocket API seamlessly into your application.



Tip

You can quickly scroll to any section of this article by using the links on the outline of this guide on the right-hand side of the page.

### Overview of WebSocket Functionality [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#overview-of-websocket-functionality "Direct link to Overview of WebSocket Functionality")

The Coinbase Developer Platform's Advanced Trade product provides two WebSocket endpoints:

- **Market Data Endpoint**: `wss://advanced-trade-ws.coinbase.com`
  This public WebSocket feed delivers real-time updates on market orders and trades for various cryptocurrency products.

- **User Order Data Endpoint**: `wss://advanced-trade-ws-user.coinbase.com`
  This authenticated WebSocket feed provides real-time updates on the user’s orders, including order status and updates on active trades.

Both endpoints provide live data streams using WebSocket connections, enabling developers to receive real-time updates on trading activity, order books, and market movements. This guide will cover how to correctly establish these WebSocket connections, manage subscriptions, and handle potential errors during integration.

## 2. Setting Up WebSocket Connections [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#2-setting-up-websocket-connections "Direct link to 2. Setting Up WebSocket Connections")

To integrate with the Coinbase Advanced Trade WebSockets, developers need to establish a WebSocket connection with either the Market Data or User Order Data endpoints. This section will guide you through the process of setting up these WebSocket connections and ensuring they remain active.

### WebSocket Endpoints [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#websocket-endpoints "Direct link to WebSocket Endpoints")

**Market Data Endpoint**: `wss://advanced-trade-ws.coinbase.com`
This endpoint provides real-time market data, including updates on orders, trades, and price changes for various cryptocurrency pairs. Authentication is not required for most channels on this endpoint.

**User Order Data Endpoint**: `wss://advanced-trade-ws-user.coinbase.com`
This endpoint provides updates related to a user's orders, including order status, fills, and real-time changes. It requires authentication using a JWT (JSON Web Token).

### Basic Connection Setup [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#basic-connection-setup "Direct link to Basic Connection Setup")

After establishing a WebSocket connection, the server expects a subscription message to be sent within 5 seconds; otherwise, the connection will be terminated. This subscription message tells the WebSocket server which channels and products the client wants to receive data for. Developers can subscribe to multiple channels, but each subscription must be sent in a unique message.

### Example: Connecting Without Authentication (Market Data Endpoint) [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#example-connecting-without-authentication-market-data-endpoint "Direct link to Example: Connecting Without Authentication (Market Data Endpoint)")

For public data, you can set up a basic WebSocket connection without authentication. Here is an example in Python that connects to the market data WebSocket and subscribes to the `ticker` channel for the BTC-USD product.
First, let’s install the necessary dependency::

`pip install websocket`

```codeBlockLines_p187
import websocket
import json

# Market Data WebSocket URL
WS_URL = "wss://advanced-trade-ws.coinbase.com"

def on_open(ws):
    # Subscribe to the ticker channel for BTC-USD
    subscribe_message = {
        "type": "subscribe",
        "product_ids": ["BTC-USD"],
        "channel": "ticker"
    }
    ws.send(json.dumps(subscribe_message))
    print("Subscribed to BTC-USD ticker channel")

def on_message(ws, message):
    data = json.loads(message)
    print(f"Received message: {data}")

def on_error(ws, error):
    print(f"Error: {error}")

def on_close(ws):
    print("Connection closed")

# Create the WebSocket connection
ws = websocket.WebSocketApp(
    WS_URL,
    on_open=on_open,
    on_message=on_message,
    on_error=on_error,
    on_close=on_close
)
ws.run_forever()

```

In this example, once the connection is established, the client sends a subscription message to the `ticker` channel for the BTC-USD product. The WebSocket then begins streaming real-time price updates for that product.

### Example: Connecting With Authentication (User Order Data Endpoint) [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#example-connecting-with-authentication-user-order-data-endpoint "Direct link to Example: Connecting With Authentication (User Order Data Endpoint)")

For user-specific data, such as order updates, you must authenticate using a JWT. Below is an example in Python that connects to the User Order Data WebSocket and subscribes to the `user` channel.
First, let’s install the necessary dependencies:

```codeBlockLines_p187
pip install websocket "pyjwt[crypto]"

import websocket
import json
import jwt  # PyJWT library
import time
import uuid

# User Order Data WebSocket URL
WS_USER_URL = "wss://advanced-trade-ws-user.coinbase.com"

# Example JWT generation (Replace with your actual API_KEY and SIGNING_KEY)
API_KEY = "organizations/{org_id}/apiKeys/{key_id}"
SIGNING_KEY = "-----BEGIN EC PRIVATE KEY-----\nYOUR_PRIVATE_KEY_HERE\n-----END EC PRIVATE KEY-----\n"

def generate_jwt():
    current_time = int(time.time())
    payload = {
        "iss": "cdp",
        "nbf": current_time,
        "exp": current_time + 120,  # JWT valid for 120 seconds
        "sub": API_KEY,
    }
    headers = {
        "kid": API_KEY,
        "nonce": uuid.uuid4().hex
    }
    return jwt.encode(payload, SIGNING_KEY, algorithm="ES256", headers=headers)

def on_open(ws):
    # Generate JWT
    token = generate_jwt()

    # Subscribe to the user channel for BTC-USD orders
    subscribe_message = {
        "type": "subscribe",
        "channel": "user",
        "product_ids": ["BTC-USD"],
        "jwt": token
    }
    ws.send(json.dumps(subscribe_message))
    print("Subscribed to user channel for BTC-USD orders")

def on_message(ws, message):
    data = json.loads(message)
    print(f"Received message: {data}")

def on_error(ws, error):
    print(f"Error: {error}")

def on_close(ws):
    print("Connection closed")

# Create the WebSocket connection
ws = websocket.WebSocketApp(
    WS_USER_URL,
    on_open=on_open,
    on_message=on_message,
    on_error=on_error,
    on_close=on_close
)

ws.run_forever()

```

In this authenticated example, we generate a JWT using the PyJWT library and include it in the subscription message for the user channel. This allows the client to receive real-time updates related to the user's orders for the BTC-USD product.

## 3. Authentication and Subscriptions [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#3-authentication-and-subscriptions "Direct link to 3. Authentication and Subscriptions")

WebSocket connections that interact with user-specific data on the Coinbase Developer Platform's Advanced Trade product require authentication via JSON Web Tokens (JWTs). This section will guide developers through generating JWTs, subscribing to channels, and managing multiple subscriptions effectively.

### Generating and Using JWT Tokens [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#generating-and-using-jwt-tokens "Direct link to Generating and Using JWT Tokens")

To subscribe to user-specific channels, such as the `user` or `futures_balance_summary` channels, you must include a valid JWT in the subscription message. The JWT is generated using your API key and signing key.

### Steps to Generate a JWT Token: [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#steps-to-generate-a-jwt-token "Direct link to Steps to Generate a JWT Token:")

- Obtain your API key and signing key from the Coinbase Developer Platform.
- Use the JWT to authenticate when subscribing to user-related data channels.
- JWT tokens expire after 2 minutes, so they must be refreshed regularly.

### Example: Generating a JWT in Python [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#example-generating-a-jwt-in-python "Direct link to Example: Generating a JWT in Python")

First, ensure you have the required dependencies installed:

`pip install websocket-client PyJWT cryptography`

Then, generate the JWT for authentication:

```codeBlockLines_p187
import jwt  # PyJWT library
import time
import uuid

# Example API and Signing Keys (replace with actual values)
API_KEY = "organizations/{org_id}/apiKeys/{key_id}"
SIGNING_KEY = "-----BEGIN EC PRIVATE KEY-----\nYOUR_PRIVATE_KEY_HERE\n-----END EC PRIVATE KEY-----\n"

def generate_jwt():
    current_time = int(time.time())
    payload = {
        "iss": "cdp",
        "nbf": current_time,
        "exp": current_time + 120,  # valid for 120 seconds
        "sub": API_KEY,
    }
    headers = {
        "kid": API_KEY,
        "nonce": uuid.uuid4().hex
    }
    token = jwt.encode(payload, SIGNING_KEY, algorithm="ES256", headers=headers)
    return token

# Example JWT
token = generate_jwt()
print(f"Generated JWT: {token}")

```

This JWT must be included in all subscription messages for user-specific channels.

### Subscribing to Channels [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#subscribing-to-channels "Direct link to Subscribing to Channels")

To receive data from WebSocket channels, you need to send a subscription message after establishing the WebSocket connection. Each channel subscription must specify the product IDs (e.g., BTC-USD, ETH-USD) and, if required, a JWT for authentication.

### Example Subscription Message (Authenticated User Channel) [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#example-subscription-message-authenticated-user-channel "Direct link to Example Subscription Message (Authenticated User Channel)")

Here’s how to subscribe to the `user` channel for receiving updates on your orders:

```codeBlockLines_p187
subscribe_message = {
    "type": "subscribe",
    "channel": "user",
    "product_ids": ["BTC-USD"],
    "jwt": generate_jwt()
}

```

### Example Subscription Message (Market Data Channel) [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#example-subscription-message-market-data-channel "Direct link to Example Subscription Message (Market Data Channel)")

For public market data, no JWT is required:

```codeBlockLines_p187
subscribe_message = {
    "type": "subscribe",
    "product_ids": ["BTC-USD", "ETH-USD"],
    "channel": "ticker"
}

```

### Channel Overview [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#channel-overview "Direct link to Channel Overview")

Coinbase Advanced Trade WebSockets provide access to multiple channels, each serving different purposes. Below is an overview of the available channels:

| Channel                   | Description                                                   | Authentication Required |
| ------------------------- | ------------------------------------------------------------- | ----------------------- |
| ticker                    | Real-time price updates every time a match happens            | No                      |
| ticker\_batch             | Real-time price updates every 5000 milliseconds               | No                      |
| market\_trades            | Real-time updates every time a market trade happens           | No                      |
| status                    | Sends all products and currencies on a preset interval        | No                      |
| level2                    | All updates and easiest way to keep order book snapshot       | No                      |
| candles                   | Price updates aggregated into time intervals                  | No                      |
| user                      | Only sends messages that include the authenticated user       | Yes                     |
| heartbeats                | Real-time server pings to keep all connections open           | No                      |
| futures\_balance\_summary | Real-time updates every time a user's futures balance changes | Yes                     |

Each subscription can handle only one channel at a time, so if you want to receive data from multiple channels, send a separate subscription message for each.

### Best Practices for Subscriptions [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#best-practices-for-subscriptions "Direct link to Best Practices for Subscriptions")

1. **Load Balancing Across WebSocket Connections**
   When subscribing to multiple channels or products, it is recommended to spread the load across different WebSocket connections. For example, instead of subscribing to multiple high-volume products (like BTC-USD and ETH-USD) on the same connection, open separate WebSocket connections for each. This reduces the risk of dropped messages and helps distribute inbound traffic more efficiently.
2. **Using the Heartbeats Channel**
   The `heartbeats` channel sends periodic heartbeat messages to ensure the WebSocket connection remains active, especially when there are no frequent updates in other channels (e.g., illiquid markets). It is a best practice to subscribe to the `heartbeats` channel alongside other channels to prevent connections from closing due to inactivity.

### Example Heartbeats Subscription: [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#example-heartbeats-subscription "Direct link to Example Heartbeats Subscription:")

```codeBlockLines_p187
subscribe_message = {
    "type": "subscribe",
    "channel": "heartbeats"
}

```

Including the heartbeats subscription ensures that the WebSocket connection stays open, even when there is a lack of updates on other subscribed channels.

## 4. WebSocket Channels Overview [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#4-websocket-channels-overview "Direct link to 4. WebSocket Channels Overview")

Coinbase’s Advanced Trade WebSockets offer various channels that provide real-time market data and user-specific information. This section gives an overview of the available channels, indicates which channels require authentication, and provides sample code to subscribe and unsubscribe from these channels.

### Which Channels Require Authentication? [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#which-channels-require-authentication "Direct link to Which Channels Require Authentication?")

- Public Channels (No Authentication Required): These channels are used to receive market data and do not require authentication. They include:
  - level2
  - ticker
  - ticker\_batch
  - candles
  - heartbeats
  - market\_trades
  - status
- Private Channels (JWT Authentication Required): These channels provide user-specific data and require the inclusion of a valid JWT token in the subscription message. They include:
  - user
  - futures\_balance\_summary

### Sample Code for Subscriptions [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#sample-code-for-subscriptions "Direct link to Sample Code for Subscriptions")

Below are examples of how to subscribe to and unsubscribe from various channels using Python. These examples demonstrate both public and private channels.

### Subscribing to a Public Channel (e.g., Ticker Channel) [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#subscribing-to-a-public-channel-eg-ticker-channel "Direct link to Subscribing to a Public Channel (e.g., Ticker Channel)")

Public channels do not require authentication, so you can simply send a subscription message after establishing the WebSocket connection.

```codeBlockLines_p187
import websocket
import json

def on_open(ws):
    # Subscribe to the ticker channel for BTC-USD
    subscribe_message = {
        "type": "subscribe",
        "product_ids": ["BTC-USD"],
        "channel": "ticker"
    }
    ws.send(json.dumps(subscribe_message))
    print("Subscribed to BTC-USD ticker channel")

# Set up WebSocket connection
ws = websocket.WebSocketApp("wss://advanced-trade-ws.coinbase.com", on_open=on_open)
ws.run_forever()

```

### Subscribing to a Private Channel (e.g., User Channel) [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#subscribing-to-a-private-channel-eg-user-channel "Direct link to Subscribing to a Private Channel (e.g., User Channel)")

Private channels require a JWT for authentication. Use the following code to subscribe to the `user` channel:

```codeBlockLines_p187
import websocket
import json

def on_open(ws):
    jwt_token = generate_jwt()  # Replace with your JWT generation logic

    # Subscribe to the user channel
    subscribe_message = {
        "type": "subscribe",
        "channel": "user",
        "product_ids": ["BTC-USD"],
        "jwt": jwt_token
    }
    ws.send(json.dumps(subscribe_message))
    print("Subscribed to user channel for BTC-USD")

# Set up WebSocket connection
ws = websocket.WebSocketApp("wss://advanced-trade-ws-user.coinbase.com", on_open=on_open)
ws.run_forever()

```

### Unsubscribing from a Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#unsubscribing-from-a-channel "Direct link to Unsubscribing from a Channel")

To unsubscribe from a channel, send a message similar to the subscription message but with "type": "unsubscribe". You can unsubscribe from either public or private channels using this format.
Example: Unsubscribing from the Ticker Channel

```codeBlockLines_p187
def unsubscribe(ws):
    unsubscribe_message = {
        "type": "unsubscribe",
        "product_ids": ["BTC-USD"],
        "channel": "ticker"
    }
    ws.send(json.dumps(unsubscribe_message))
    print("Unsubscribed from BTC-USD ticker channel")

```

### Example in JavaScript for Subscribing to a Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#example-in-javascript-for-subscribing-to-a-channel "Direct link to Example in JavaScript for Subscribing to a Channel")

If developers are using JavaScript, they can use the ws library in a Node.js environment to subscribe to a WebSocket channel. Here’s how to subscribe to the ticker channel:

```codeBlockLines_p187
const WebSocket = require('ws');

const ws = new WebSocket('wss://advanced-trade-ws.coinbase.com');

ws.on('open', function open() {
  const subscribeMessage = JSON.stringify({
    type: "subscribe",
    product_ids: ["BTC-USD"],
    channel: "ticker"
  });

  ws.send(subscribeMessage);
  console.log("Subscribed to BTC-USD ticker channel");
});

ws.on('message', function incoming(data) {
  console.log(`Received: ${data}`);
});

```

## 5. Conclusion [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#5-conclusion "Direct link to 5. Conclusion")

Successfully integrating with Coinbase’s Advanced Trade WebSocket API begins with a solid understanding of connection setup, authentication, and subscription management. Below is a summary of the essential best practices covered in this guide:

1. **Ensuring Stable WebSocket Connections**
   - Send a subscription message within 5 seconds of establishing a connection to prevent disconnection.
   - Include the heartbeats channel in your subscriptions to keep connections alive during periods of low activity.
2. **Authenticating with JWTs for Secure Data Access**
   - Use JWT tokens for authenticated channels like the user channel.
   - Refresh JWT tokens every 2 minutes to maintain uninterrupted access to private data channels.
3. **Managing Subscriptions Across Channels**
   - Use a unique subscription message for each channel and product combination.
   - Spread subscriptions across multiple WebSocket connections to optimize data flow and maintain stability, especially when handling multiple high-volume channels.

By applying these practices, developers can achieve a reliable integration with Coinbase’s Advanced Trade WebSockets. This foundational setup will support real-time trading data and user-specific information, preparing your application to scale as needed. In the next part of this guide, you’ll learn to troubleshoot and optimize your WebSocket performance to handle real-time data with precision and efficiency.

### Resources [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-setup-guide#resources "Direct link to Resources")

For further reading and support, please refer to the following resources:

- **Coinbase API Documentation**:

  - [Coinbase Advanced Trade API Overview](https://docs.cdp.coinbase.com/advanced-trade/docs/welcome)
  - [WebSocket API Reference](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview)
- **Sample Code and Developer Guides**:

  - [Official Coinbase GitHub](https://github.com/coinbase-samples)
- **Support Channels**:

  - [Coinbase Developer Discord](https://discord.com/invite/cdp)

These resources will provide additional context and examples to help you with more complex implementations, as well as access to community and technical support. Feel free to engage with the Coinbase developer community on Discord for troubleshooting and tips from fellow developers.

# WS-ADVANCED-GUIDE

# Advanced Trade WebSockets: Troubleshooting, Performance Optimization, and Advanced Features

## 1. Introduction [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#1-introduction "Direct link to 1. Introduction")

In this section of the Coinbase Advanced Trade WebSockets guide, we’ll focus on optimizing your WebSocket connection for reliability and efficiency while addressing common integration challenges. You’ll find troubleshooting strategies for connection issues, message handling tips, and methods to avoid rate limits. Additionally, we’ll cover advanced WebSocket features like monitoring order updates and futures balances, helping you maximize the potential of Coinbase’s real-time trading data. By the end of this guide, you’ll have the best practices and technical insights needed to build high-performance applications using Coinbase’s Advanced Trade WebSocket API.



Tip

You can quickly scroll to any section of this article by using the links on the outline of this guide on the right-hand side of the page.

## 2. Common Integration Issues and Troubleshooting [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#2-common-integration-issues-and-troubleshooting "Direct link to 2. Common Integration Issues and Troubleshooting")

When integrating with Coinbase Advanced Trade WebSockets, developers may encounter issues such as disconnections, dropped messages, and rate limits. This section provides practical solutions to these common challenges.

### Connection and Disconnection Problems [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#connection-and-disconnection-problems "Direct link to Connection and Disconnection Problems")

WebSocket connections can be interrupted for various reasons, including network instability, server restarts, or idle timeouts. Handling these disconnections gracefully is crucial for ensuring seamless data flow in your application.

### Handling Disconnects and Reconnects [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#handling-disconnects-and-reconnects "Direct link to Handling Disconnects and Reconnects")

To handle disconnections:

- Implement an event listener for the `on_close` event in your WebSocket client.
- Attempt to reconnect with an exponential backoff strategy to avoid overwhelming the server with connection attempts.
- Resubscribe to all necessary channels upon reconnection.

**Example: Reconnecting After Disconnection (Python)**

```codeBlockLines_p187
import websocket
import time

def on_close(ws):
    print("Connection closed. Reconnecting...")
    reconnect(ws)

def reconnect(ws):
    time.sleep(5)  # Wait for 5 seconds before reconnecting
    ws.run_forever()

# Add this to your WebSocketApp to handle reconnections
ws = websocket.WebSocketApp("wss://advanced-trade-ws.coinbase.com", on_close=on_close)
ws.run_forever()

```

### Subscription Timeout (5 Seconds) [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#subscription-timeout-5-seconds "Direct link to Subscription Timeout (5 Seconds)")

To avoid connection termination, you must send a valid subscription message within 5 seconds of opening a WebSocket connection. If no message is sent within this time, the server will disconnect you.

**Best Practice**: Ensure your WebSocket client immediately sends a subscription message upon connection.

```codeBlockLines_p187
def on_open(ws):
    # Send subscription message upon connection
    subscribe_message = {
        "type": "subscribe",
        "product_ids": ["BTC-USD"],
        "channel": "ticker"
    }
    ws.send(json.dumps(subscribe_message))

```

### Using Heartbeats to Prevent Idle Timeouts [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#using-heartbeats-to-prevent-idle-timeouts "Direct link to Using Heartbeats to Prevent Idle Timeouts")

WebSocket connections may be closed if there are no updates from subscribed channels, particularly for illiquid trading pairs. To prevent this, subscribe to the heartbeats channel to receive periodic messages that keep the connection alive.

```codeBlockLines_p187
subscribe_message = {
    "type": "subscribe",
    "channel": "heartbeats"
}

```

The heartbeats channel sends a message every second, ensuring the connection remains open even during periods of low activity.

### Dropped or Out-of-Order Messages [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#dropped-or-out-of-order-messages "Direct link to Dropped or Out-of-Order Messages")

Due to the nature of WebSocket connections, some messages might be dropped or arrive out of order, especially in high-volume trading environments.

**Monitoring and Handling Sequence Numbers**

Each message in the WebSocket stream contains a sequence number. Sequence numbers increase by one with each new message. If you detect a gap in the sequence numbers, it indicates that a message was dropped.

If sequence numbers arrive out of order, they can usually be ignored, but gaps in sequence numbers should prompt a resync of your order book or real-time data.

**Best Practice**: Implement logic to detect gaps in sequence numbers and trigger resynchronization of your data feed when necessary.

```codeBlockLines_p187
def on_message(ws, message):
    data = json.loads(message)
    # Check for sequence gaps
    if "sequence_num" in data:
        current_sequence = data["sequence_num"]
        if current_sequence > last_sequence + 1:
            print(f"Gap detected. Resync required. Last: {last_sequence}, Current: {current_sequence}")
            # Trigger resync logic here
        last_sequence = current_sequence

```

### Resynchronizing the Order Book [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#resynchronizing-the-order-book "Direct link to Resynchronizing the Order Book")

If gaps are detected, you may need to resubscribe to the level2 channel and request a fresh snapshot of the order book to ensure consistency.

### Rate Limiting [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#rate-limiting "Direct link to Rate Limiting")

Coinbase Advanced Trade WebSockets enforce rate limits to ensure fair usage. Exceeding these limits may result in temporary disconnections or throttling.

**Rate Limits Overview**

- **Authenticated connections**: Rate-limited at 750 messages per second per IP.
- **Unauthenticated connections**: Rate-limited at 8 messages per second per IP.

**Best Practices for Handling Rate Limits**:

1. Avoid sending unnecessary messages or frequent reconnections.
2. Spread out your subscriptions across multiple WebSocket connections if you're monitoring multiple products or high-volume channels.
3. Use batch channels (like `ticker_batch`) instead of individual channels where possible to reduce message volume.

**Example: Using Ticker Batch Channel**

```codeBlockLines_p187
subscribe_message = {
    "type": "subscribe",
    "product_ids": ["BTC-USD", "ETH-USD"],
    "channel": "ticker_batch"
}

```

The `ticker_batch` channel sends price updates every 5 seconds instead of immediately, reducing the total number of messages and helping you stay within rate limits.

## 3. Best Practices for WebSocket Performance [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#3-best-practices-for-websocket-performance "Direct link to 3. Best Practices for WebSocket Performance")

Ensuring optimal WebSocket performance is critical for applications that depend on real-time data from the Coinbase Developer Platform's Advanced Trade product. This section outlines best practices for optimizing WebSocket connections, managing high-volume channels, and implementing a reliable failover strategy.

### Optimizing WebSocket Connections [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#optimizing-websocket-connections "Direct link to Optimizing WebSocket Connections")

For applications handling high-frequency data, optimizing the WebSocket connection can greatly improve performance and reliability.

1. **Buffer Size Management**
   WebSocket clients often receive a high volume of data, especially when subscribing to channels like level2 or market\_trades. To prevent data loss or dropped messages, it’s important to configure the largest possible receive buffer size for your WebSocket client.

**Best Practice**: Increase the buffer size based on your system's capabilities and the expected volume of data.
For example, in Python's socket library, you can adjust the buffer size via the setsockopt method:

```codeBlockLines_p187
import socket
ws = websocket.WebSocketApp("wss://advanced-trade-ws.coinbase.com")

# Adjust buffer size
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1048576) # 1MB buffer

```

Ensure that your client library supports buffer size adjustments and configure it to handle large bursts of incoming messages.

2. **Using Batch Channels to Reduce Message Traffic**

For products like ticker, subscribing to the `ticker_batch` channel instead of the `ticker` channel reduces message traffic by batching updates at regular intervals (e.g., every 5 seconds). This reduces bandwidth usage and ensures that your WebSocket connection remains efficient, particularly for high-volume products.

**Example: Subscribing to Ticker Batch Channel**:

```codeBlockLines_p187
subscribe_message = {
    "type": "subscribe",
    "product_ids": ["BTC-USD", "ETH-USD"],
    "channel": "ticker_batch"
}
ws.send(json.dumps(subscribe_message))

```

The `ticker_batch` channel provides the same information as ticker but in a more bandwidth-friendly format, making it ideal for applications that don’t need updates for every trade.

### Handling High-Volume Channels [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#handling-high-volume-channels "Direct link to Handling High-Volume Channels")

Some channels, such as `level2` and `market_trades`, provide detailed, high-frequency updates that can overwhelm a WebSocket connection if not handled properly. The following strategies will help manage these high-volume channels effectively.

#### Managing Data from level2 and market\_trades Channels [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#managing-data-from-level2-and-market_trades-channels "Direct link to Managing Data from level2 and market_trades Channels")

The `level2` channel provides order book updates, while the market\_trades channel delivers trade data. Both of these can generate a significant amount of traffic during periods of high market activity.

**Best Practice**: Implement message batching or aggregation in your client to reduce the load. Rather than processing every message immediately, group messages into batches before updating your local state.

**Example**: Implementing Message Batching

```codeBlockLines_p187
import json

message_buffer = []

def on_message(ws, message):
    data = json.loads(message)
    message_buffer.append(data)

    # Process batch of 100 messages
    if len(message_buffer) >= 100:
        process_messages(message_buffer)
        message_buffer.clear()

def process_messages(messages):
    # Aggregate or process the batch of messages here
    print(f"Processing {len(messages)} messages")

```

This approach reduces the processing overhead and network strain by handling multiple messages at once.

#### Failover Strategy [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#failover-strategy "Direct link to Failover Strategy")

Ensuring continuity in WebSocket connections is essential, especially for critical trading systems. Coinbase provides two WebSocket endpoints—advanced-trade-ws for public data and advanced-trade-ws-user for authenticated user data. You can design a failover mechanism by connecting to both endpoints and switching to the secondary WebSocket connection in the event of a failure.

**Setting Up Primary and Failover WebSocket Connections**

When connecting to user-specific data using advanced-trade-ws-user, it’s best to use advanced-trade-ws as a backup for public data to maintain availability during potential downtime.

**Example: WebSocket Failover Strategy**

```codeBlockLines_p187
primary_url = "wss://advanced-trade-ws-user.coinbase.com"
failover_url = "wss://advanced-trade-ws.coinbase.com"

def connect_ws(url):
    return websocket.WebSocketApp(url, on_message=on_message, on_close=on_close)

def on_close(ws):
    print(f"Connection closed. Switching to failover...")
    failover_ws = connect_ws(failover_url)
    failover_ws.run_forever()

# Start with the primary WebSocket connection
ws = connect_ws(primary_url)
ws.run_forever()

```

In this failover setup, if the primary connection (advanced-trade-ws-user) fails, the client will automatically switch to the secondary connection (advanced-trade-ws). This ensures that market data continues to be received even if the primary WebSocket is temporarily unavailable.

## 4. Advanced WebSocket Features [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#4-advanced-websocket-features "Direct link to 4. Advanced WebSocket Features")

In addition to market data, Coinbase's Advanced Trade WebSockets offer advanced features like the user channel for monitoring order and account data in real-time, and the futures\_balance\_summary channel for managing futures balances and margin requirements. These features are especially useful for applications that require user-specific information and futures trading insights.

### User Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#user-channel "Direct link to User Channel")

The `user` channel provides real-time updates on a user's open orders, order status changes, and any modifications made to their account. This channel is particularly useful for tracking open positions, managing active orders, and responding to changes in order status (e.g., when an order is filled, canceled, or rejected).

### Subscribing to and Managing Order Updates [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#subscribing-to-and-managing-order-updates "Direct link to Subscribing to and Managing Order Updates")

To subscribe to the `user` channel, you must authenticate using a JWT and specify the product IDs you're interested in. This subscription will stream real-time updates related to your orders and account.

**Example: Subscribing to the User Channel**

```codeBlockLines_p187
import websocket
import json

def on_open(ws):
    # Example JWT (replace with actual JWT token)
    jwt_token = generate_jwt()

    # Subscribe to the user channel for BTC-USD orders
    subscribe_message = {
        "type": "subscribe",
        "channel": "user",
        "product_ids": ["BTC-USD"],
        "jwt": jwt_token
    }
    ws.send(json.dumps(subscribe_message))
    print("Subscribed to user channel for BTC-USD orders")

# Set up WebSocket connection (similar to previous examples)
ws = websocket.WebSocketApp("wss://advanced-trade-ws-user.coinbase.com", on_open=on_open)
ws.run_forever()

```

Once subscribed, you'll receive updates on all of your open orders, including status changes (e.g., open, filled, canceled).

**Example Use Cases for Tracking Positions and Order Statuses**

- **Real-Time Order Monitoring**: The user channel allows developers to build interfaces that provide up-to-the-second updates on order status (e.g., if an order is partially filled or canceled).
- **Order Management Systems**: Applications can use this channel to automatically adjust active positions based on real-time updates, such as closing an order or modifying the order book in response to execution events.

**Sample Order Update Message**:

```codeBlockLines_p187
{
  "channel": "user",
  "sequence_num": 123456,
  "events": [\
    {\
      "type": "update",\
      "order_id": "abc123",\
      "status": "FILLED",\
      "filled_value": "500.00",\
      "filled_size": "0.05",\
      "remaining_size": "0"\
    }\
  ]
}

```

In this example, the message indicates that an order has been fully filled, and your system could update the user interface or trigger automated workflows based on this event.

### Futures Balance Summary [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#futures-balance-summary "Direct link to Futures Balance Summary")

For users engaged in futures trading, the `futures_balance_summary` channel provides real-time updates on their futures balances, margin requirements, and position details. This channel is crucial for monitoring margin levels and ensuring that traders have sufficient collateral to support their positions.

### Monitoring Futures Balances and Margin Requirements [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#monitoring-futures-balances-and-margin-requirements "Direct link to Monitoring Futures Balances and Margin Requirements")

The `futures_balance_summary` channel provides detailed information about the user's buying power, margin requirements, unrealized profits and losses (PnL), and liquidation thresholds. This data is essential for traders to understand their risk exposure and for automated systems to make margin-related decisions.

**Example: Subscribing to the Futures Balance Summary Channel**

```codeBlockLines_p187
import websocket
import json

def on_open(ws):
    # Example JWT (replace with actual JWT token)
    jwt_token = generate_jwt()

    # Subscribe to the futures_balance_summary channel
    subscribe_message = {
        "type": "subscribe",
        "channel": "futures_balance_summary",
        "jwt": jwt_token
    }
    ws.send(json.dumps(subscribe_message))
    print("Subscribed to futures_balance_summary channel")

# Set up WebSocket connection
ws = websocket.WebSocketApp("wss://advanced-trade-ws-user.coinbase.com", on_open=on_open)
ws.run_forever()

```

### Real-Time Futures Position Updates [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#real-time-futures-position-updates "Direct link to Real-Time Futures Position Updates")

Once subscribed, the `futures_balance_summary` channel streams real-time updates about the user’s futures balance. This includes details like total buying power, unrealized PnL, margin requirements, and liquidation thresholds.

**Sample Futures Balance Summary Message**:

```codeBlockLines_p187
{
  "channel": "futures_balance_summary",
  "sequence_num": 78910,
  "events": [\
    {\
      "type": "snapshot",\
      "fcm_balance_summary": {\
        "futures_buying_power": "5000.00",\
        "total_usd_balance": "10000.00",\
        "unrealized_pnl": "-100.00",\
        "initial_margin": "2000.00",\
        "available_margin": "3000.00",\
        "liquidation_threshold": "1500.00"\
      }\
    }\
  ]
}

```

In this message, the user's futures buying power, margin, and unrealized PnL are provided. Applications can use this information to:

- **Monitor Margin Levels**: Automatically alert users if they are nearing their liquidation threshold.
- **Manage Risk**: Implement logic to adjust trading strategies or trigger margin calls based on real-time balance updates.

By utilizing the advanced features of the `user` and `futures_balance_summary` channels, developers can build powerful tools for managing user orders and futures positions in real-time. These features allow for granular tracking of account activity, ensuring that users can make informed decisions and stay ahead of market changes.

## 5. Conclusion [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#5-conclusion "Direct link to 5. Conclusion")

This guide has covered best practices and strategies to ensure that your Coinbase Advanced Trade WebSocket integration is both reliable and high-performing. By optimizing connections and effectively troubleshooting issues, you can ensure smooth and continuous data flow. Below is a summary of the key techniques from this guide:

1. **Troubleshooting Connection and Message Issues**

- Implement reconnection logic with an exponential backoff strategy to handle disconnections gracefully.
- Use sequence numbers to monitor message continuity and detect any dropped or out-of-order messages, resyncing data as needed.

2. **Optimizing WebSocket Performance**

- Adjust buffer sizes in your WebSocket client to accommodate high data volumes from channels like level2.
- Use batch channels, such as ticker\_batch, to manage message traffic and reduce bandwidth usage for high-frequency updates.

3. **Leveraging Advanced Features for Real-Time Insights**

- Utilize the user channel for real-time tracking of orders and positions, allowing dynamic and responsive trading applications.
- Monitor the futures\_balance\_summary channel to track margin and balance changes, helping users manage risk effectively.

By following these practices, you can build a robust, high-performance system capable of handling the demands of real-time data and trading insights. With this in-depth understanding of WebSocket optimization and advanced features, your application will be well-equipped to provide a seamless experience for end-users in Coinbase’s Advanced Trade environment.

### Resources [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-advanced-guide#resources "Direct link to Resources")

For further reading and support, please refer to the following resources:

- **Coinbase API Documentation**:

  - [Coinbase Advanced Trade API Overview](https://docs.cdp.coinbase.com/advanced-trade/docs/welcome)
  - [WebSocket API Reference](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview)
- **Sample Code and Developer Guides**:

  - [Official Coinbase GitHub](https://github.com/coinbase-samples)
- **Support Channels**:

  - [Coinbase Developer Discord](https://discord.com/invite/cdp)

These resources will provide additional context and examples to help you with more complex implementations, as well as access to community and technical support. Feel free to engage with the Coinbase developer community on Discord for troubleshooting and tips from fellow developers.

# WS-AUTH

# Advanced Trade WebSocket Authentication

This guide explains how to authenticate requests to the Advanced Trade [WebSocket API](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels) server channels. It assumes that you have already [created API keys](https://docs.cdp.coinbase.com/advanced-trade/docs/getting-started).

## Sending Messages with API Keys [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#sending-messages-with-api-keys "Direct link to Sending Messages with API Keys")

### Making Requests [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#making-requests "Direct link to Making Requests")

Use the code samples below to generate/export a JSON Web Token (JWT) and make an authenticated request.



Info

WebSocket JWTs (vs those for REST API) are not built with a request method or request path.

### Generating a JWT [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#generating-a-jwt "Direct link to Generating a JWT")

Regardless of which [code snippet](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#code-samples) you use, follow these steps:

1. Replace `key name` and `key secret` with your key name and private key. `key secret` is a multi-line key and newlines must be preserved to properly parse the key. Do this on one line with `\n` escaped newlines, or with a multi-line string.
2. Run the generation script that prints the command `export JWT=...`.
3. Run the generated command to save your JWT.



Caution

Your JWT expires after 2 minutes, after which all requests are unauthenticated.

### Code samples [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#code-samples "Direct link to Code samples")

The easiest way to generate a JWT is to use the built-in functions in our [Python SDK](https://docs.cdp.coinbase.com/advanced-trade/docs/sdk-overview) as described below.
Otherwise, use the code samples below to generate/export a JWT and make an authenticated request.

## Python SDK

## Python

## Go

## JavaScript

## PHP

## Java

## C++

## TypeScript

## C\#

## Ruby

1. Install the SDK.

```codeBlockLines_p187
pip3 install coinbase-advanced-py

```

2. In the console, run: `python main.py` (or whatever your file name is).

3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(python main.py)`.

```codeBlockLines_p187
from coinbase import jwt_generator

api_key = "organizations/{org_id}/apiKeys/{key_id}"
api_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def main():
    jwt_token = jwt_generator.build_ws_jwt(api_key, api_secret)
    print(f"export JWT={jwt_token}")

if __name__ == "__main__":
    main()

```

1. Install dependencies PyJWT and cryptography.

```codeBlockLines_p187
pip install PyJWT
pip install cryptography

```

2. In the console, run: `python main.py` (or whatever your file name is).
3. Set JWT to that output, or export the JWT to the environment with `export JWT=$(node main.py)`.

```codeBlockLines_p187
import jwt
from cryptography.hazmat.primitives import serialization
import time
import secrets

key_name     = "organizations/{org_id}/apiKeys/{key_id}"
key_secret   = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def build_jwt():
    private_key_bytes = key_secret.encode('utf-8')
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)

    jwt_payload = {
        'sub': key_name,
        'iss': "cdp",
        'nbf': int(time.time()),
        'exp': int(time.time()) + 120,
    }

    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm='ES256',
        headers={'kid': key_name, 'nonce': secrets.token_hex()},
    )

    return jwt_token

def main():
    jwt_token = build_jwt()

    print(f"export JWT={jwt_token}")

if __name__ == "__main__":
    main()

```

1. Create a new directory and generate a Go file called `main.go`.
2. Paste the Go snippet below into `main.go`.
3. Run `go mod init jwt-generator` and `go mod tidy` to generate `go.mod` and `go.sum` and manage your dependencies.
4. In the console, run: go run `main.go`.
5. Set your JWT with that output, or export the JWT to environment with `export JWT=$(node main.go)`.

```codeBlockLines_p187
package main

import (
    "crypto/rand"
    "crypto/x509"
    "encoding/pem"
    "fmt"
    "math"
    "math/big"
    "time"

    log "github.com/sirupsen/logrus"
    "gopkg.in/go-jose/go-jose.v2"
    "gopkg.in/go-jose/go-jose.v2/jwt"
)

const (
    keyName     = "organizations/{org_id}/apiKeys/{key_id}"
    keySecret   = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
)

type APIKeyClaims struct {
    *jwt.Claims
}

func buildJWT() (string, error) {
    block, _ := pem.Decode([]byte(keySecret))
    if block == nil {
        return "", fmt.Errorf("jwt: Could not decode private key")
    }

    key, err := x509.ParseECPrivateKey(block.Bytes)
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }

    sig, err := jose.NewSigner(
        jose.SigningKey{Algorithm: jose.ES256, Key: key},
        (&jose.SignerOptions{NonceSource: nonceSource{}}).WithType("JWT").WithHeader("kid", keyName),
    )
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }

    cl := &APIKeyClaims{
        Claims: &jwt.Claims{
            Subject:   keyName,
            Issuer:    "cdp",
            NotBefore: jwt.NewNumericDate(time.Now()),
            Expiry:    jwt.NewNumericDate(time.Now().Add(2 * time.Minute)),
        },
    }
    jwtString, err := jwt.Signed(sig).Claims(cl).CompactSerialize()
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }
    return jwtString, nil
}

var max = big.NewInt(math.MaxInt64)

type nonceSource struct{}

func (n nonceSource) Nonce() (string, error) {
    r, err := rand.Int(rand.Reader, max)
    if err != nil {
        return "", err
    }
    return r.String(), nil
}

func main() {
    jwt, err := buildJWT()

    if err != nil {
        log.Errorf("error building jwt: %v", err)
    }
    fmt.Println("export JWT=" + jwt)
}

```

1. Install jsonwebtoken.

```codeBlockLines_p187
npm install jsonwebtoken

```

2. In the console, run: `node main.js` (or whatever your file name is).
3. Set JWT to that output, or export the JWT to environment with `export JWT=$(node main.js)`.

```codeBlockLines_p187
const { sign } = require('jsonwebtoken');
const crypto = require('crypto');

const key_name       = 'organizations/{org_id}/apiKeys/{key_id}';
const key_secret = '-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n';

const algorithm = 'ES256';

const token = sign(
        {
           iss: 'cdp',
           nbf: Math.floor(Date.now() / 1000),
           exp: Math.floor(Date.now() / 1000) + 120,
           sub: key_name,
        },
        key_secret,
        {
           algorithm,
           header: {
              kid: key_name,
              nonce: crypto.randomBytes(16).toString('hex'),
           },
        }
);
console.log('export JWT=' + token);

```

1. Add PHP dependencies with Composer (for JWT and environment variable management):

```codeBlockLines_p187
composer require firebase/php-jwt
composer require vlucas/phpdotenv

```

2. Run `generate_jwt.php` (or a filename of your choice).

3. Output the JWT to the command line and use a shell script to export it:

```codeBlockLines_p187
export JWT=$(php generate_jwt.php)

```

> Code Snippet

```codeBlockLines_p187
<?php
require 'vendor/autoload.php';
use Firebase\JWT\JWT;
use \Dotenv\Dotenv;

// Load environment variables
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

function buildJwt() {
    $keyName = $_ENV['NAME'];
    $keySecret = str_replace('\\n', "\n", $_ENV['PRIVATE_KEY']);

    $privateKeyResource = openssl_pkey_get_private($keySecret);
    if (!$privateKeyResource) {
        throw new Exception('Private key is not valid');
    }
    $time = time();
    $nonce = bin2hex(random_bytes(16));  // Generate a 32-character hexadecimal nonce
    $jwtPayload = [\
        'sub' => $keyName,\
        'iss' => 'cdp',\
        'nbf' => $time,\
        'exp' => $time + 120,  // Token valid for 120 seconds from now\
    ];
    $headers = [\
        'typ' => 'JWT',\
        'alg' => 'ES256',\
        'kid' => $keyName,  // Key ID header for JWT\
        'nonce' => $nonce  // Nonce included in headers for added security\
    ];
    $jwtToken = JWT::encode($jwtPayload, $privateKeyResource, 'ES256', $keyName, $headers);
    return $jwtToken;
}

```

1. Add Java Dependencies to your project's Maven or Gradle configuration:

```codeBlockLines_p187
nimbus-jose-jwt (version 9.39), bcpkix-jdk18on (version 1.78), and java-dotenv (version 5.2.2)

```

2. Compile your Java application to generates a JWT, for example:

```codeBlockLines_p187
mvn compile

```

3. Capture and export the JWT output from your Java application to an environment variable:

```codeBlockLines_p187
export JWT=$(mvn exec:java -Dexec.mainClass=Main)

```

> Code Snippet

```codeBlockLines_p187
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.*;
import com.nimbusds.jwt.*;
import java.security.interfaces.ECPrivateKey;
import java.util.Map;
import java.util.HashMap;
import java.time.Instant;
import java.util.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.KeyFactory;
import java.io.StringReader;
import java.security.PrivateKey;
import java.security.Security;
import io.github.cdimascio.dotenv.Dotenv;

public class Main {
    public static void main(String[] args) throws Exception {
        // Register BouncyCastle as a security providerx
        Security.addProvider(new BouncyCastleProvider());

        // Load environment variables
        Dotenv dotenv = Dotenv.load();
        String privateKeyPEM = dotenv.get("PRIVATE_KEY").replace("\\n", "\n");
        String name = dotenv.get("NAME");

        // create header object
        Map<String, Object> header = new HashMap<>();
        header.put("alg", "ES256");
        header.put("typ", "JWT");
        header.put("kid", name);
        header.put("nonce", String.valueOf(Instant.now().getEpochSecond()));

        // create data object
        Map<String, Object> data = new HashMap<>();
        data.put("iss", "cdp");
        data.put("nbf", Instant.now().getEpochSecond());
        data.put("exp", Instant.now().getEpochSecond() + 120);
        data.put("sub", name);

        // Load private key
        PEMParser pemParser = new PEMParser(new StringReader(privateKeyPEM));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
        Object object = pemParser.readObject();
        PrivateKey privateKey;

        if (object instanceof PrivateKey) {
            privateKey = (PrivateKey) object;
        } else if (object instanceof org.bouncycastle.openssl.PEMKeyPair) {
            privateKey = converter.getPrivateKey(((org.bouncycastle.openssl.PEMKeyPair) object).getPrivateKeyInfo());
        } else {
            throw new Exception("Unexpected private key format");
        }
        pemParser.close();

        // Convert to ECPrivateKey
        KeyFactory keyFactory = KeyFactory.getInstance("EC");
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());
        ECPrivateKey ecPrivateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);

        // create JWT
        JWTClaimsSet.Builder claimsSetBuilder = new JWTClaimsSet.Builder();
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            claimsSetBuilder.claim(entry.getKey(), entry.getValue());
        }
        JWTClaimsSet claimsSet = claimsSetBuilder.build();

        JWSHeader jwsHeader = new JWSHeader.Builder(JWSAlgorithm.ES256).customParams(header).build();
        SignedJWT signedJWT = new SignedJWT(jwsHeader, claimsSet);

        JWSSigner signer = new ECDSASigner(ecPrivateKey);
        signedJWT.sign(signer);

        String sJWT = signedJWT.serialize();
        System.out.println(sJWT);
    }
}

```

1. Install C++ project dependencies like so:

```codeBlockLines_p187
apt-get update
apt-get install libcurlpp-dev libssl-dev
git clone https://github.com/Thalhammer/jwt-cpp
cd jwt-cpp
mkdir build && cd build
cmake ..
make
make install

```

2. After you've saved your code to a file name, for example main.cpp, compile the program:

```codeBlockLines_p187
g++ main.cpp -o myapp -lcurlpp -lcurl -lssl -lcrypto -I/usr/local/include -L/usr/local/lib -ljwt -std=c++17

```

3. Capture and export the JWT output from your C++ application to an environment variable:

```codeBlockLines_p187
export JWT=$(./myapp)

```

> Code Snippet

```codeBlockLines_p187
#include <iostream>
#include <sstream>
#include <string>
#include <curlpp/cURLpp.hpp>
#include <curlpp/Easy.hpp>
#include <curlpp/Options.hpp>
#include <jwt-cpp/jwt.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/pem.h>
#include <openssl/rand.h>

std::string create_jwt() {
    // Set request parameters
    std::string key_name = "organizations/{org_id}/apiKeys/{key_id}";
    std::string key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

    // Generate a random nonce
    unsigned char nonce_raw[16];
    RAND_bytes(nonce_raw, sizeof(nonce_raw));
    std::string nonce(reinterpret_cast<char*>(nonce_raw), sizeof(nonce_raw));

    // Create JWT token
    auto token = jwt::create()
        .set_subject(key_name)
        .set_issuer("cdp")
        .set_not_before(std::chrono::system_clock::now())
        .set_expires_at(std::chrono::system_clock::now() + std::chrono::seconds{120})
        .set_header_claim("kid", jwt::claim(key_name))
        .set_header_claim("nonce", jwt::claim(nonce))
        .sign(jwt::algorithm::es256(key_name, key_secret));

    return token;
};

int main() {
    try {
        std::string token = create_jwt();
        std::cout << "Generated JWT Token: " << token << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
};

```

1. Install the JSON Web Token and TypeScript dependencies:

```codeBlockLines_p187
npm install jsonwebtoken
npm install @types/jsonwebtoken
npm install -g typescript

```

2. Create a TypeScript file named `main.ts` and add the following code:

```codeBlockLines_p187
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';

const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
const keySecret = `-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
   -----END EC PRIVATE KEY-----`;
const algorithm = 'ES256';


const generateJWT = (): string => {
     const payload = {
       iss: 'cdp',
       nbf: Math.floor(Date.now() / 1000),
       exp: Math.floor(Date.now() / 1000) + 120,
       sub: keyName,
     };

     const header = {
       alg: algorithm,
       kid: keyName,
       nonce: crypto.randomBytes(16).toString('hex'),
     };

     return jwt.sign(payload, keySecret, { algorithm, header });
};

const main = () => {
     const token = generateJWT();
     console.log(token);
};

main();

```

3. Compile the TypeScript file to JavaScript:

```codeBlockLines_p187
tsc main.ts

```

This will generate a `main.js` file.

4. Run the generated JavaScript file:

```codeBlockLines_p187
node main.js

```

5. Set the JWT to the output, or export the JWT to the environment with:

```codeBlockLines_p187
export JWT=$(node main.js)

```

> Code Snippet

```codeBlockLines_p187
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';

const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
const keySecret = `-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
-----END EC PRIVATE KEY-----`;
const algorithm = 'ES256';

const generateJWT = (): string => {
  const payload = {
    iss: 'cdp',
    nbf: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 120,
    sub: keyName,
  };

  const header = {
    alg: algorithm,
    kid: keyName,
    nonce: crypto.randomBytes(16).toString('hex'),
  };

  return jwt.sign(payload, keySecret, { algorithm, header });
};

const main = () => {
  const token = generateJWT();
  console.log(token);
};

main();

```

1. Create a new console project by running the following command:

```codeBlockLines_p187
dotnet new console

```

2. Open the Program.cs file in a text editor or IDE (e.g., Visual Studio Code, Visual Studio, or any text editor). Replace the contents of Program.cs with the provided bellow in the Code Snippet.

3. Install C# project dependencies like so:

```codeBlockLines_p187
dotnet add package Microsoft.IdentityModel.Tokens
dotnet add package System.IdentityModel.Tokens.Jwt
dotnet add package Jose-JWT

```

4. Build the project by running the following command:

```codeBlockLines_p187
dotnet build

```

5. Run the project by running the following command:

```codeBlockLines_p187
dotnet run

```

> Code Snippet

```codeBlockLines_p187
// Environment is .NET 6.0 C#

using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using Jose;

namespace JwtTest {
    internal class Program {

        static Random random = new Random();

        static void Main(string[] args) {

            string name = "organizations/{org_id}/apiKeys/{key_id}";
            string cbPrivateKey = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

            string key = parseKey(cbPrivateKey);
            string token = generateToken(name, key);

            Console.WriteLine($"Token is valid? {isTokenValid(token, name, key)}");

        }

        static string generateToken(string name, string secret) {
             var privateKeyBytes = Convert.FromBase64String(secret); // Assuming PEM is base64 encoded
             using var key = ECDsa.Create();
             key.ImportECPrivateKey(privateKeyBytes, out _);

             var payload = new Dictionary<string, object>
             {
                 { "sub", name },
                 { "iss", "coinbase-cloud" },
                 { "nbf", Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
                 { "exp", Convert.ToInt64((DateTime.UtcNow.AddMinutes(1) - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
             };

             var extraHeaders = new Dictionary<string, object>
             {
                 { "kid", name },
                 // add nonce to prevent replay attacks with a random 10 digit number
                 { "nonce", randomHex(10) },
                 { "typ", "JWT"}
             };

             var encodedToken = JWT.Encode(payload, key, JwsAlgorithm.ES256, extraHeaders);

            // print token
            Console.WriteLine(encodedToken);
            return encodedToken;
        }

        static bool isTokenValid(string token, string tokenId, string secret) {
            if (token == null)
                return false;

            var key = ECDsa.Create();
            key?.ImportECPrivateKey(Convert.FromBase64String(secret), out _);

            var securityKey = new ECDsaSecurityKey(key) { KeyId = tokenId };

            try {
                var tokenHandler = new JwtSecurityTokenHandler();
                tokenHandler.ValidateToken(token, new TokenValidationParameters {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = securityKey,
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ClockSkew = TimeSpan.Zero
                }, out var validatedToken);

                return true;
            } catch {
                return false;
            }
        }

        static string parseKey(string key) {
            List<string> keyLines = new List<string>();
            keyLines.AddRange(key.Split('\n', StringSplitOptions.RemoveEmptyEntries));

            keyLines.RemoveAt(0);
            keyLines.RemoveAt(keyLines.Count - 1);

            return String.Join("", keyLines);
        }

        static string randomHex(int digits) {
            byte[] buffer = new byte[digits / 2];
            random.NextBytes(buffer);
            string result = String.Concat(buffer.Select(x => x.ToString("X2")).ToArray());
            if (digits % 2 == 0)
                return result;
            return result + random.Next(16).ToString("X");
        }

    }
}

```

1. Install dependencies `JWT` and `OpenSSL`.

```codeBlockLines_p187
gem install JWT
gem install OpenSSL

```

2. In the console, run: `ruby main.rb` (or whatever your file name is).

3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(ruby main.rb)`.

```codeBlockLines_p187
require 'jwt'
require 'openssl'
require 'time'
require 'securerandom'

Key_name = "organizations/{org_id}/apiKeys/{key_id}"
Key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def build_jwt()
    header = {
      typ: 'JWT',
      kid: Key_name,
      nonce: SecureRandom.hex(16)
    }

    claims = {
      sub: Key_name,
      iss: 'cdp',
      aud: ['cdp_service'],
      nbf: Time.now.to_i,
      exp: Time.now.to_i + 120, # Expiration time: 2 minute from now.
    }

    private_key = OpenSSL::PKey::read(Key_secret)
    JWT.encode(claims, private_key, 'ES256', header)
  end

token = build_jwt()
puts token

```

## Sending Messages without API Keys [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#sending-messages-without-api-keys "Direct link to Sending Messages without API Keys")

### Subscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#subscribing "Direct link to Subscribing")

```codeBlockLines_p187
// Request
// Subscribe to ETH-USD and ETH-EUR with the level2 channel
{
    "type": "subscribe",
    "product_ids": [\
        "ETH-USD",\
        "ETH-EUR"\
    ],
    "channel": "level2"
}

```

### Unsubscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#unsubscribing "Direct link to Unsubscribing")

```codeBlockLines_p187
// Request
{
    "type": "unsubscribe",
    "product_ids": [\
        "ETH-USD",\
        "ETH-EUR"\
    ],
    "channel": "level2"
}

```

## Sequence Numbers [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth#sequence-numbers "Direct link to Sequence Numbers")

Most feed messages contain a sequence number. Sequence numbers are increasing integer values for each product, with each new message being exactly one sequence number greater than the one before it.

Sequence numbers that are _greater than one integer value_ from the previous number indicate that a message has been dropped. Sequence numbers that are _less_ than the previous number can be ignored or represent a message that has arrived out of order.

In either situation you may need to perform logic to make sure your system is in the correct state.



Caution

Even though a WebSocket connection is over TCP, the WebSocket servers receive market data in a manner that can result in dropped messages. Your feed consumer should be designed to handle sequence gaps and out of order messages, or should use channels that guarantee delivery of messages.



Tip

To guarantee that messages are delivered and your order book is in sync, consider using the [level2 channel](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#level2-channel).

**See Also:**

- [WebSocket Legacy Keys](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth-legacy)
- [WebSocket Channels](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels)

# WS-CHANNELS

# Advanced Trade WebSocket Channels



Use heartbeats to keep all subscriptions open

Most channels close within 60-90 seconds if no updates are sent. Subscribe to [heartbeats](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#heartbeats-channel) to keep all subscriptions open.

The Coinbase Advanced Trade Market Data WebSocket feed provides the following channels:

| Channel                                                                                                                    | Description                                                   | Requires Authentication |
| -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ----------------------- |
| **[heartbeats](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#heartbeats-channel)**                         | **Real-time server pings to keep all connections open**       | No                      |
| [candles](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#candles-channel)                                   | Real-time updates on product candles                          | No                      |
| [status](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#status-channel)                                     | Sends all products and currencies on a preset interval        | No                      |
| [ticker](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#ticker-channel)                                     | Real-time price updates every time a match happens            | No                      |
| [ticker\_batch](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#ticker-batch-channel)                        | Real-time price updates every 5000 milli-seconds              | No                      |
| [level2](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#level2-channel)                                     | All updates and easiest way to keep order book snapshot       | No                      |
| [user](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#user-channel)                                         | Only sends messages that include the authenticated user       | _Yes_                   |
| [market\_trades](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#market-trades-channel)                      | Real-time updates every time a market trade happens           | No                      |
| [futures\_balance\_summary](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#futures-balance-summary-channel) | Real-time updates every time a user's futures balance changes | _Yes_                   |

Refer to the documentation on [subscribing to a WebSocket channel](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#subscribing).



Tip

For the most reliable connection, authenticate with a CDP API key when subscribing to any channel.



Info

Subscribing to "-USDC" based products are only available on the user channel. Other channels will return the same data as the corresponding "-USD" based products. USDT-USDC and EURC-USDC are available on all channels.

## Heartbeats Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#heartbeats-channel "Direct link to Heartbeats Channel")

Subscribe to the `heartbeats` channel to receive heartbeats messages every second. Heartbeats include a `heartbeat_counter` which verifies that no messages were missed.



Tip

Subscribing to the heartbeats channel, alongside other channels, ensures that all subscriptions stay open when updates are sparse. This is useful, for example, when fetching market data for illiquid pairs.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "channel": "heartbeats",
  "jwt": "XYZ"
}

```

A heartbeats message is of the type `heartbeats` as seen below.

```codeBlockLines_p187
// Heartbeats Message
{
  "channel": "heartbeats",
  "client_id": "",
  "timestamp": "2023-06-23T20:31:26.122969572Z",
  "sequence_num": 0,
  "events": [\
    {\
      "current_time": "2023-06-23 20:31:56.121961769 +0000 UTC m=+91717.525857105",\
      "heartbeat_counter": "3049"\
    }\
  ]
}

```

## Candles Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#candles-channel "Direct link to Candles Channel")

Subscribe to the `candles` channel to receive candles messages for specific products with updates every second. Candles are grouped into buckets (granularities) of five minutes.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD"],
  "channel": "candles",
  "jwt": "XYZ"
}

```

A candles message is of the type `candles` and some of its parameters include:

- `start` - string representation of the UNIX timestamp of the candle.
- `high` and `low` - highest and lowest prices during the bucket interval.
- `open` and `close` - prices of the first and last trade respectively.
- `volume` - base amount that has been traded during this interval.
- `product_id` - product identifier for this candle

```codeBlockLines_p187
// Candles Message
{
  "channel": "candles",
  "client_id": "",
  "timestamp": "2023-06-09T20:19:35.39625135Z",
  "sequence_num": 0,
  "events": [\
    {\
      "type": "snapshot",\
      "candles": [\
        {\
          "start": "1688998200",\
          "high": "1867.72",\
          "low": "1865.63",\
          "open": "1867.38",\
          "close": "1866.81",\
          "volume": "0.20269406",\
          "product_id": "ETH-USD"\
        }\
      ]\
    }\
  ]
}

```

## Market Trades Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#market-trades-channel "Direct link to Market Trades Channel")

The `market_trades` channel sends market trades for a specified product on a preset interval. Clients should provide an array of `product_ids` for which they would like status subscriptions.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "market_trades",
  "jwt": "XYZ"
}

```

A market trades message is of the type `snapshot` or `update`, and contains an array of market trades. Each market trade belongs to a `side`, which refers to the makers side, and can be of type `BUY`, or `SELL`. The channel collects all updates over the last 250 ms and sends them as an `update` -- so an `update` can contain one or many trades, depending on the last 250 ms of trading volume.

```codeBlockLines_p187
// Market Trades Message
{
  "channel": "market_trades",
  "client_id": "",
  "timestamp": "2023-02-09T20:19:35.39625135Z",
  "sequence_num": 0,
  "events": [\
    {\
      "type": "snapshot",\
      "trades": [\
        {\
          "trade_id": "000000000",\
          "product_id": "ETH-USD",\
          "price": "1260.01",\
          "size": "0.3",\
          "side": "BUY",\
          "time": "2019-08-14T20:42:27.265Z"\
        }\
      ]\
    }\
  ]
}

```

## Status Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#status-channel "Direct link to Status Channel")

The `status` channel sends all products and currencies on a preset interval. Clients should provide an array of `product_ids` for which they would like status subscriptions.



Caution

The `status` channel, like most channels, closes within 60-90 seconds when there are no updates. For example, if you listen for `BTC-USD` updates and nothing changes within 60-90 seconds (which is common), the channel closes. To avoid this, subscribe to the [heartbeats](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#heartbeats-channel) in addition to your other channels.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "status",
  "jwt": "XYZ"
}

```

```codeBlockLines_p187
// Status Message
{
  "channel": "status",
  "client_id": "",
  "timestamp": "2023-02-09T20:29:49.753424311Z",
  "sequence_num": 0,
  "events": [\
    {\
      "type": "snapshot",\
      "products": [\
        {\
          "product_type": "SPOT",\
          "id": "BTC-USD",\
          "base_currency": "BTC",\
          "quote_currency": "USD",\
          "base_increment": "0.00000001",\
          "quote_increment": "0.01",\
          "display_name": "BTC/USD",\
          "status": "online",\
          "status_message": "",\
          "min_market_funds": "1"\
        }\
      ]\
    }\
  ]
}

```

## Ticker Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#ticker-channel "Direct link to Ticker Channel")

The `ticker` channel provides real-time price updates every time a match happens. It batches updates in case of cascading matches, greatly reducing bandwidth requirements.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "ticker",
  "jwt": "XYZ"
}

```

```codeBlockLines_p187
// Ticker message
{
  "channel": "ticker",
  "client_id": "",
  "timestamp": "2023-02-09T20:30:37.167359596Z",
  "sequence_num": 0,
  "events": [\
    {\
      "type": "snapshot",\
      "tickers": [\
        {\
          "type": "ticker",\
          "product_id": "BTC-USD",\
          "price": "21932.98",\
          "volume_24_h": "16038.28770938",\
          "low_24_h": "21835.29",\
          "high_24_h": "23011.18",\
          "low_52_w": "15460",\
          "high_52_w": "48240",\
          "price_percent_chg_24_h": "-4.15775596190603",\
          "best_bid": "21931.98",\
          "best_bid_quantity": "8000.21",\
          "best_ask": "21933.98",\
          "best_ask_quantity": "8038.07770938"\
        }\
      ]\
    }\
  ]
}

```

## Ticker Batch Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#ticker-batch-channel "Direct link to Ticker Batch Channel")

The `ticker_batch` channel provides latest price updates **every 5000 milliseconds** (5 seconds) if there is a change. It has the same JSON message schema as the [`ticker` channel](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#ticker-channel), except the `channel` field will have a value of `ticker_batch` and it currently doesn't provide best bid or best ask fields.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "ticker_batch",
  "jwt": "XYZ"
}

```

## Level2 Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#level2-channel "Direct link to Level2 Channel")

The `level2` channel guarantees delivery of all updates and is the easiest way to keep a snapshot of the order book.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "level2",
  "jwt": "XYZ"
}

```



Tip

Subscribe to the `level2` channel to guarantee that messages are delivered and your order book is in sync.

The level2 channel sends a message with fields, `type` ("snapshot" or "update"), `product_id`, and `updates`. The field `updates` is an array of objects of `{price_level, new_quantity, event_time, side}` to represent the entire order book. The `event_time` property is the time of the event as recorded by our trading engine.



Info

The `new_quantity` property is the updated size at that price level, not a delta. A `new_quantity` of "0" indicates the price level can be removed.

```codeBlockLines_p187
// Example:
{
  "channel": "l2_data",
  "client_id": "",
  "timestamp": "2023-02-09T20:32:50.714964855Z",
  "sequence_num": 0,
  "events": [\
    {\
      "type": "snapshot",\
      "product_id": "BTC-USD",\
      "updates": [\
        {\
          "side": "bid",\
          "event_time": "1970-01-01T00:00:00Z",\
          "price_level": "21921.73",\
          "new_quantity": "0.06317902"\
        },\
        {\
          "side": "bid",\
          "event_time": "1970-01-01T00:00:00Z",\
          "price_level": "21921.3",\
          "new_quantity": "0.02"\
        }\
      ]\
    }\
  ]
}

```

## User Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#user-channel "Direct link to User Channel")

[![](https://img.shields.io/badge/User%20Channel-Authentication%20Required-0a639a)](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth)

The `user` channel sends updates on all of a user's open orders and current positions, including all subsequent updates of those orders and positions.

The `user` channel expects one connection per user:

- This connection accepts multiple product IDs in a `product_ids` array. If none are provided, the WebSocket subscription is open to all product IDs.
- To subscribe to new `product_ids`, close your previous connection by unsubscribing and open a new connection with `product_ids` added to the array.



Tip

Subscribing to the User channel returns all `OPEN` orders, batched by 50, in the first few messages of the stream. For example, if you have 109 orders, you will get a snapshot containing 50 orders, followed by a patch of 50 orders, followed by a patch of 9 orders. To know when all of your open orders are returned, look for the first message with less than 50 orders.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "channel": "user",
  "product_ids": ["BTC-USD"],
  "jwt": "XYZ"
}

```

```codeBlockLines_p187
// User message
{
  "channel": "user",
  "client_id": "",
  "timestamp": "2023-02-09T20:33:57.609931463Z",
  "sequence_num": 0,
  "events": [\
    {\
      "type": "snapshot",\
      "orders": [\
        {\
          "avg_price": "50000",\
          "cancel_reason": "",\
          "client_order_id": "XXX",\
          "completion_percentage": "100.00",\
          "contract_expiry_type": "UNKNOWN_CONTRACT_EXPIRY_TYPE",\
          "cumulative_quantity": "0.01",\
          "filled_value": "500",\
          "leaves_quantity": "0",\
          "limit_price": "50000",\
          "number_of_fills": "1",\
          "order_id": "YYY",\
          "order_side": "BUY",\
          "order_type": "Limit",\
          "outstanding_hold_amount": "0",\
          "post_only": "false",\
          "product_id": "BTC-USD",\
          "product_type": "SPOT",\
          "reject_reason": "",\
          "retail_portfolio_id": "ZZZ",\
          "risk_managed_by": "UNKNOWN_RISK_MANAGEMENT_TYPE",\
          "status": "FILLED",\
          "stop_price": "",\
          "time_in_force": "GOOD_UNTIL_CANCELLED",\
          "total_fees": "2",\
          "total_value_after_fees": "502",\
          "trigger_status": "INVALID_ORDER_TYPE",\
          "creation_time": "2024-06-21T18:29:13.909347Z",\
          "end_time": "0001-01-01T00:00:00Z",\
          "start_time": "0001-01-01T00:00:00Z"\
        }\
      ],\
      "positions": {\
        "perpetual_futures_positions": [\
          {\
            "product_id": "BTC-PERP-INTX",\
            "portfolio_uuid": "018c4b12-9f87-7c36-897d-28fb6a1ea88d",\
            "vwap": "63049.9",\
            "entry_vwap": "0",\
            "position_side": "Long",\
            "margin_type": "Cross",\
            "net_size": "0.0041",\
            "buy_order_size": "0",\
            "sell_order_size": "0",\
            "leverage": "1",\
            "mark_price": "63049.9",\
            "liquidation_price": "0",\
            "im_notional": "258.5046",\
            "mm_notional": "17.061304",\
            "position_notional": "258.5046",\
            "unrealized_pnl": "0",\
            "aggregated_pnl": "258.50459"\
          }\
        ],\
        "expiring_futures_positions": [\
          {\
            "product_id": "BIT-28JUN24-CDE",\
            "side": "Long",\
            "number_of_contracts": "1",\
            "realized_pnl": "0",\
            "unrealized_pnl": "-21.199999999999932",\
            "entry_price": "64150"\
          }\
        ]\
      }\
    }\
  ]
}

```

#### Orders Fields [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#orders-fields "Direct link to Orders Fields")

| Field                     | Description                                                                                                                                                                                                                                                                                                                                                                       |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `avg_price`               | Average filled price of the order so far                                                                                                                                                                                                                                                                                                                                          |
| `cancel_reason`           | Reason for order cancellation                                                                                                                                                                                                                                                                                                                                                     |
| `client_order_id`         | Unique identifier of order specified by client                                                                                                                                                                                                                                                                                                                                    |
| `completion_percentage`   | Percentage of order completion                                                                                                                                                                                                                                                                                                                                                    |
| `contract_expiry_type`    | Can be one of: <br>- `UNKNOWN_CONTRACT_EXPIRY`<br>- `EXPIRING`<br>- `PERPETUAL`                                                                                                                                                                                                                                                                                                   |
| `cumulative_quantity`     | Amount the order is filled, in base currency                                                                                                                                                                                                                                                                                                                                      |
| `filled_value`            | Value of the filled order                                                                                                                                                                                                                                                                                                                                                         |
| `leaves_quantity`         | Amount remaining, in same currency as order was placed in (quote or base)                                                                                                                                                                                                                                                                                                         |
| `limit_price`             | Can be one of: <br>- `Limit Price`: Order is Limit or Stop Limit type<br>- `0`: Order is not Limit or Stop Limit type                                                                                                                                                                                                                                                             |
| `number_of_fills`         | Number of fills for the order                                                                                                                                                                                                                                                                                                                                                     |
| `order_id`                | Unique identifier of order                                                                                                                                                                                                                                                                                                                                                        |
| `order_side`              | Can be one of: <br>- `BUY`<br>- `SELL`                                                                                                                                                                                                                                                                                                                                            |
| `order_type`              | Can be one of: <br>- `LIMIT`<br>- `MARKET`<br>- `STOP_LIMIT`                                                                                                                                                                                                                                                                                                                      |
| `outstanding_hold_amount` | Outstanding hold amount for the order                                                                                                                                                                                                                                                                                                                                             |
| `post_only`               | Can be one of: <br>- `true`<br>- `false`                                                                                                                                                                                                                                                                                                                                          |
| `product_id`              | The product ID for which this order was placed                                                                                                                                                                                                                                                                                                                                    |
| `product_type`            | Can be one of: <br>- `UNKNOWN_PRODUCT_TYPE`<br>- `SPOT`<br>- `FUTURE`                                                                                                                                                                                                                                                                                                             |
| `reject_Reason`           | Reason for order rejection                                                                                                                                                                                                                                                                                                                                                        |
| `retail_portfolio_id`     | The ID of the portfolio this order is associated with.                                                                                                                                                                                                                                                                                                                            |
| `risk_managed_by`         | Can be one of: <br>- `UNKNOWN_RISK_MANAGEMENT_TYPE`<br>- `MANAGED_BY_FCM`<br>- `MANAGED_BY_VENUE`                                                                                                                                                                                                                                                                                 |
| `status`                  | Can be one of: <br>- `PENDING`: Order is not yet open<br>- `OPEN`: Order is waiting to be fully filled<br>- `FILLED`: Order is 100% filled<br>- `CANCEL_QUEUED`: Order queued to be cancelled by user or system<br>- `CANCELLED`: Order was cancelled by user or system<br>- `EXPIRED`: TWAP order was not filled by the expiry time<br>- `FAILED`: Order cannot be placed at all |
| `stop_price`              | Can be one of: <br>- `Stop Price`: Order is Stop Limit type<br>- `0`: Order is not Stop Limit type                                                                                                                                                                                                                                                                                |
| `time_in_force`           | Can be one of: <br>- `UNKNOWN_TIME_IN_FORCE`<br>- `GOOD_UNTIL_DATE_TIME`<br>- `GOOD_UNTIL_CANCELLED`<br>- `IMMEDIATE_OR_CANCEL`<br>- `FILL_OR_KILL`                                                                                                                                                                                                                               |
| `total_fees`              | Commission paid for the order                                                                                                                                                                                                                                                                                                                                                     |
| `total_value_after_fees`  | Total value of the order after fees                                                                                                                                                                                                                                                                                                                                               |
| `trigger_status`          | Can be one of: <br>- `UNKNOWN_TRIGGER_STATUS`<br>- `INVALID_ORDER_TYPE`<br>- `STOP_PENDING`<br>- `STOP_TRIGGERED`                                                                                                                                                                                                                                                                 |
| `creation_time`           | When the order was placed                                                                                                                                                                                                                                                                                                                                                         |
| `end_time`                | - `End Time`: Order has end time <br>- `0001-01-01T00:00:00Z`: End Time not applicable                                                                                                                                                                                                                                                                                            |
| `start_time`              | - `Start Time`: Order has start time <br>- `0001-01-01T00:00:00Z`: Start Time not applicable                                                                                                                                                                                                                                                                                      |

#### Positions Fields [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#positions-fields "Direct link to Positions Fields")

Numeric values are in units of USDC.



Info

The `positions` fields are in beta and is currently returned as an empty array by default. To enable access to the `positions` fields in the User WebSocket channel, please reach out to us through [Discord](https://discord.com/invite/cdp).

##### Perpetual Futures [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#perpetual-futures "Direct link to Perpetual Futures")

| Field               | Description                                                                                                                                               |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `product_id`        | Name of the instrument the position is in, e.g. `BTC-PERP-INTX`                                                                                           |
| `portfolio_uuid`    | The uuid of the portfolio this order is associated with                                                                                                   |
| `vwap`              | The price of the position based on the last settlement period                                                                                             |
| `entry_vwap`        | Volume weighted entry price of the position (not reset to the last funding price)                                                                         |
| `position_side`     | The side of the position. Can be one of: <br>- `Long`<br>- `Short`                                                                                        |
| `margin_type`       | The margin type of the position. Can be one of: <br>- `Cross`: Indicating a cross margin position<br>- `Isolated`: Indicating an isolated margin position |
| `net_size`          | The size of the position with positive values reflecting a long position and negative values reflecting a short position                                  |
| `buy_order_size`    | Cumulative size of all the open buy orders                                                                                                                |
| `sell_order_size`   | Cumulative size of all the open sell orders                                                                                                               |
| `leverage`          | The leverage of the position                                                                                                                              |
| `mark_price`        | The current mark price value for the instrument of this position used in risk and margin calculations                                                     |
| `liquidation_price` | Price at which the position will be liquidated at                                                                                                         |
| `im_notional`       | The amount this position contributes to the initial margin                                                                                                |
| `mm_notional`       | The amount this position contributes to the maintenance margin                                                                                            |
| `position_notional` | The notional value of the position                                                                                                                        |
| `unrealized_pnl`    | The profit or loss of this position (resets to 0 after settlement)                                                                                        |
| `aggregated_pnl`    | The total profit or loss of this position since the initial opening of the position                                                                       |

#### Expiring Futures [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#expiring-futures "Direct link to Expiring Futures")

| Field                 | Description                                                        |
| --------------------- | ------------------------------------------------------------------ |
| `product_id`          | Name of the instrument the position is in, e.g. `BTC-12Jun24-CDE`  |
| `side`                | The side of the position. Can be one of: <br>- `Long`<br>- `Short` |
| `number_of_contracts` | The size of your position in contracts                             |
| `realized_pnl`        | Your realized PnL for your position                                |
| `unrealized_pnl`      | Your current unrealized PnL for your position                      |
| `entry_price`         | The average entry price at which you entered your current position |

## Futures Balance Summary Channel [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels#futures-balance-summary-channel "Direct link to Futures Balance Summary Channel")

[![](https://img.shields.io/badge/Futures%20Balance%20Summary%20Channel-Authentication%20Required-0a639a)](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth)

The `futures_balance_summary` channel sends updates on all of a user's futures balances, including all subsequent updates of those balances.

```codeBlockLines_p187
// Request
{
  "type": "subscribe",
  "channel": "futures_balance_summary",
  "jwt": "XYZ"
}

```

```codeBlockLines_p187
// Futures Balance Summary Message:
{
  "channel": "futures_balance_summary",
  "client_id": "",
  "timestamp": "2023-02-09T20:33:57.609931463Z",
  "sequence_num": 0,
  "events": [\
    {\
      "type": "snapshot",\
      "fcm_balance_summary":{\
        "futures_buying_power": "100.00",\
        "total_usd_balance": "200.00",\
        "cbi_usd_balance": "300.00",\
        "cfm_usd_balance": "400.00",\
        "total_open_orders_hold_amount": "500.00",\
        "unrealized_pnl": "600.00",\
        "daily_realized_pnl": "0",\
        "initial_margin": "700.00",\
        "available_margin": "800.00",\
        "liquidation_threshold": "900.00",\
        "liquidation_buffer_amount": "1000.00",\
        "liquidation_buffer_percentage": "1000",\
        "intraday_margin_window_measure":{\
          "margin_window_type":"FCM_MARGIN_WINDOW_TYPE_INTRADAY",\
          "margin_level":"MARGIN_LEVEL_TYPE_BASE",\
          "initial_margin":"100.00",\
          "maintenance_margin":"200.00",\
          "liquidation_buffer_percentage":"1000",\
          "total_hold":"100.00",\
          "futures_buying_power":"400.00"\
        },\
        "overnight_margin_window_measure":{\
          "margin_window_type":"FCM_MARGIN_WINDOW_TYPE_OVERNIGHT",\
          "margin_level":"MARGIN_LEVEL_TYPE_BASE",\
          "initial_margin":"300.00",\
          "maintenance_margin":"200.00",\
          "liquidation_buffer_percentage":"1000",\
          "total_hold":"-30.00",\
          "futures_buying_power":"2000.00"\
        }\
      }\
    }\
  ]
}

```

| Field                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `futures_buying_power`            | The amount of your cash balance that is available to trade CFM futures                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `total_usd_balance`               | Aggregate USD maintained across your CFTC-regulated futures account and your Coinbase Inc. spot account                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `cbi_usd_balance`                 | USD maintained in your Coinbase Inc. spot account                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `cfm_usd_balance`                 | USD maintained in your CFTC-regulated futures account. Funds held in your futures account are not available to trade spot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `total_open_orders_hold_amount`   | Your total balance on hold for spot and futures open orders                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `unrealized_pnl`                  | Your current unrealized PnL across all open positions                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `daily_realized_pnl`              | Your realized PnL from the current trade date. May include profit or loss from positions you've closed on the current trade date                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `initial_margin`                  | Margin required to initiate futures positions. Once futures orders are placed, these funds cannot be used to trade spot. The actual amount of funds necessary to support executed futures orders will be moved to your futures account                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `available_margin`                | Funds available to meet your anticipated margin requirement. This includes your CBI spot USD, CFM futures USD, and Futures PnL, less any holds for open spot or futures orders                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `liquidation_threshold`           | When your available funds for collateral drop to the liquidation threshold, some or all of your futures positions will be liquidated                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `liquidation_buffer_amount`       | Funds available in excess of the liquidation threshold, calculated as available margin minus liquidation threshold. If your liquidation buffer amount reaches 0, your futures positions and/or open orders will be liquidated as necessary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `liquidation_buffer_percentage`   | Funds available in excess of the liquidation threshold expressed as a percentage. If your liquidation buffer percentage reaches 0%, your futures positions and/or open orders will be liquidated as necessary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `intraday_margin_window_measure`  | The period of time used to calculate margin requirements for positions held intraday before settling overnight <br>Includes: <br>- `margin_window_type`<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_UNSPECIFIED<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_OVERNIGHT<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_WEEKEND<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_INTRADAY<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_TRANSITION<br>- `margin_level`<br>  - MARGIN\_LEVEL\_TYPE\_UNSPECIFIED<br>  - MARGIN\_LEVEL\_TYPE\_BASE<br>  - MARGIN\_LEVEL\_TYPE\_WARNING<br>  - MARGIN\_LEVEL\_TYPE\_DANGER<br>  - MARGIN\_LEVEL\_TYPE\_LIQUIDATION<br>- `initial_margin`<br>- `maintenance_margin`<br>- `liquidation_buffer_percentage`<br>- `total_hold`<br>- `futures_buying_power`     |
| `overnight_margin_window_measure` | The period of time used to calculate increased margin requirements for positions held and left unsettled overnight <br>Includes: <br>- `margin_window_type`<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_UNSPECIFIED<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_OVERNIGHT<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_WEEKEND<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_INTRADAY<br>  - FCM\_MARGIN\_WINDOW\_TYPE\_TRANSITION<br>- `margin_level`<br>  - MARGIN\_LEVEL\_TYPE\_UNSPECIFIED<br>  - MARGIN\_LEVEL\_TYPE\_BASE<br>  - MARGIN\_LEVEL\_TYPE\_WARNING<br>  - MARGIN\_LEVEL\_TYPE\_DANGER<br>  - MARGIN\_LEVEL\_TYPE\_LIQUIDATION<br>- `initial_margin`<br>- `maintenance_margin`<br>- `liquidation_buffer_percentage`<br>- `total_hold`<br>- `futures_buying_power` |

**See Also:**

- [Subscribing to WebSocket Channels](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#subscribing)
- [WebSocket Sequence Numbers](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-overview#sequence-numbers)
- [WebSocket Best Practices](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-best-practices)

# WS-RATE-LIMITS

# Advanced Trade WebSocket Rate Limits

The WebSocket feed is publicly available and its real-time market data updates provide the fastest insight into order flow and trades.

- Advanced Trade API WebSocket connections are rate-limited at **750 per second per IP address**.

- Advanced Trade API WebSocket unauthenticated messages are rate-limited at **8 per second per IP address**.



Info

You are responsible for reading the message stream and using the messages relevant for your needs, such as building real-time order books and tracking real-time trades.

**See Also:**

- [WebSocket Best Practices](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-best-practices)
- [WebSocket Channels](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-channels)

# WS-BEST-PRACTICES

# Advanced Trade WebSocket Best Practices

Some WebSocket best practices are:

- Remember [WebSocket rate limits](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-rate-limits).

- Spread subscriptions over more than one WebSocket client connection. For example, do not subscribe to BTC-USD and ETH-USD on the same channel if possible. Instead, open up two separate WebSocket connections to help load balance those inbound messages across separate connections.

- Connected clients should increase their web socket receive buffer to the largest configurable amount possible (given any client library or infrastructure limitations), due to the potential volume of data for any given product.

- Use alternative batch channels (such as `ticker_batch` instead of `ticker`) which deliver a batched version of the respective data on a set interval reducing overall traffic.

- Use `heartbeats` channel to keep your connection alive. Subscribing to the heartbeats channel alongside other channels ensures that all subscriptions remain open. This is useful, for example, when fetching marketdata for illiquid pairs.

- Subscribe to `user` channel and `futures balance summary` channel with the [advanced-trade-ws-user](wss://advanced-trade-ws-user.coinbase.com/) in order to minimize the connection timeouts. If [advanced-trade-ws-user](wss://advanced-trade-ws-user.coinbase.com/) is your primary connection, we recommend using [advanced-trade-ws](wss://advanced-trade-ws.coinbase.com/) as a failover.

# WS-AUTH-LEGACY

# Sending WebSocket Messages with Legacy Keys



Legacy keys have been expired

Beginning February 5, 2025, we expired all legacy API keys. Create new [CDP API keys](https://docs.cdp.coinbase.com/advanced-trade/docs/rest-api-auth-legacy) and update your code to continue using Coinbase App APIs.

## Subscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth-legacy#subscribing "Direct link to Subscribing")

```codeBlockLines_p187
// Request
// Subscribe to ETH-USD and ETH-EUR with the level2 channel
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2",
  "api_key": "exampleApiKey123",
  "timestamp": "1660838876",
  "signature": "00000000000000000000000000"
}

```

To subscribe to any channel, users must provide a `channel` name, `api_key`, `timestamp`, and `signature`:

- `channel` name as a string. You can only subscribe to one channel per subscription message.

- `timestamp` should be a string in [UNIX format](https://www.unixtimestamp.com/). Example: `"1677527973"`.

- `signature` should be created by:

1. Concatenating and comma-separating the timestamp, channel name, and product Ids, for example: `1660838876level2ETH-USD,ETH-EUR`.

2. Hashing this phrase with your secret key: `CryptoJS.HmacSHA256(str, secret).toString()`.

## Unsubscribing [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth-legacy#unsubscribing "Direct link to Unsubscribing")

```codeBlockLines_p187
// Request
{
  "type": "unsubscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2",
  "api_key": "exampleApiKey123",
  "timestamp": "1660839876",
  "signature": "00000000000000000000000000"
}

```

You receive a `subscriptions` message as a response to an `unsubscribe` message.

## JS Code Sample [](https://docs.cdp.coinbase.com/advanced-trade/docs/ws-auth-legacy#js-code-sample "Direct link to JS Code Sample")

This JavaScript example is for subscribing to one Advanced Trade WebSocket channel using legacy API keys.

```codeBlockLines_p187
// JS Example for subscribing to a channel
/* eslint-disable */
const WebSocket = require("ws");
const CryptoJS = require("crypto-js");
const fs = require("fs");

// Derived from your Coinbase Retail API Key
//  SIGNING_KEY: the signing key provided as a part of your API key. Also called the "SECRET KEY"
//  API_KEY: the api key provided as a part of your API key. also called the "PUBLIC KEY"
const SIGNING_KEY = "";
const API_KEY = "";

if (!SIGNING_KEY.length || !API_KEY.length) {
  throw new Error("missing mandatory environment variable(s)");
}

const CHANNEL_NAMES = {
  level2: "level2",
  user: "user",
  tickers: "ticker",
  ticker_batch: "ticker_batch",
  status: "status",
  market_trades: "market_trades",
  candles: "candles",
};

// The base URL of the API
const WS_API_URL = "wss://advanced-trade-ws.coinbase.com";

// Function to generate a signature using CryptoJS
function sign(str, secret) {
  const hash = CryptoJS.HmacSHA256(str, secret);
  return hash.toString();
}

function timestampAndSign(message, channel, products = []) {
  const timestamp = Math.floor(Date.now() / 1000).toString();
  const strToSign = `${timestamp}${channel}${products.join(",")}`;
  const sig = sign(strToSign, SIGNING_KEY);
  return { ...message, signature: sig, timestamp: timestamp };
}

const ws = new WebSocket(WS_API_URL);

function subscribeToProducts(products, channelName, ws) {
  const message = {
    type: "subscribe",
    channel: channelName,
    api_key: API_KEY,
    product_ids: products,
  };
  const subscribeMsg = timestampAndSign(message, channelName, products);
  ws.send(JSON.stringify(subscribeMsg));
}

function unsubscribeToProducts(products, channelName, ws) {
  const message = {
    type: "unsubscribe",
    channel: channelName,
    api_key: API_KEY,
    product_ids: products,
  };
  const subscribeMsg = timestampAndSign(message, channelName, products);
  ws.send(JSON.stringify(subscribeMsg));
}

function onMessage(data) {
  const parsedData = JSON.parse(data);
  fs.appendFile("Output1.txt", data, (err) => {
    // In case of a error throw err.
    if (err) throw err;
  });
}

const connections = [];
let sentUnsub = false;
for (let i = 0; i < 1; i++) {
  const date1 = new Date(new Date().toUTCString());
  const ws = new WebSocket(WS_API_URL);

  ws.on("message", function (data) {
    const date2 = new Date(new Date().toUTCString());
    const diffTime = Math.abs(date2 - date1);
    if (diffTime > 5000 && !sentUnsub) {
      unsubscribeToProducts(["BTC-USD"], CHANNEL_NAMES.user, ws);
      sentUnsub = true;
    }

    const parsedData = JSON.parse(data);
    fs.appendFile("Output1.txt", data, (err) => {
      // In case of a error throw err.
      if (err) throw err;
    });
  });

  ws.on("open", function () {
    const products = ["BTC-USD"];
    subscribeToProducts(products, CHANNEL_NAMES.user, ws);
  });

  connections.push(ws);
}

```
