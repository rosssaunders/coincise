# Authentication

# Quick Start

## Access Preparation[​](#access-preparation "Direct link to Access Preparation")

If you need to use the API, please log in to the [web page](javascript:;), then apply the API key application and complete the permission configuration, and then develop and trade according to the details of this document.

You can click [API Key Management](javascript:;) to create an API Key after login.

Each UID can create 10 Api Keys, and each Api Key can set permissions as read only or read/write.

The permissions are described as follows:

-   Read-Only permission: Read permission authorized to query data, such as market data.
-   Trade permission: Transaction permission authorized to call the interface of placing and cancelling orders.
-   Transfer permission: With this permission it authorized to transfer coins between accounts.
-   Withdraw permission: Authorized to withdraw assets from Bitget account, `noted that you can only withdraw coins through an whitelisted IP address.`

After successfully created the API key, please remember the following information:

-   `APIKey` The identity of API transactions, generated by a random algorithm.
-   `SecretKey` The private key is randomly generated by the system and used for [Signature](/api-doc/common/signature) generation.
-   `Passphrase` The password is set by the user. It should be noted that if you forgot the Passphrase, it cannot be retrieved back, and the APIKey needs to be recreated.

For security reasons, it is strongly recommended that you bind to an IP address when you create the API key

**Risk Warning**：These three keys are highly related to account security. Please keep in mind DO NOT DISCLOSE **Secretkey and Passphrase** to anyone at any circumstances, even with BitGet employees. Leaking any one of these three keys may cause the loss of your assets. If you find by any chance that the APIKey is compromized, please delete the APIKey as soon as possible.

## Interface Type[​](#interface-type "Direct link to Interface Type")

Interfaces are mainly divided into two types:

-   Public Interface
-   Private Interface

**Public Interface**

The public interface can be used to obtain configuration information and market data. Public requests can be used without authentication.

**Private Interface**

The private interface can be used for order management and account management. Every private request must be [Signed](/api-doc/common/signature).

The private interface will be verified from server side with your API Key info.

## Access Restriction[​](#access-restriction "Direct link to Access Restriction")

This chapter mainly focuses on access restrictions:

-   Rest API will return 429 status when the access exceeds the frequency limit: the request is too frequent.

**Rest API**

The rate limit of interfaces is based on UID or IP. You can get detailed information from the separated API document page.

Frequency limit rules:

1.  The rate limit of each API endpoint is marked on the doc page;
2.  The rate limit of each API interface is calculated independently;
3.  The overall rate limit is 6000/IP/Min

> **Source:** https://www.bitget.com/api-doc/common/quick-start


---

# Signature

## API Verification[​](#api-verification "Direct link to API Verification")

### Initiate a request[​](#initiate-a-request "Direct link to Initiate a request")

The header of all REST requests must contain the following http headers：

-   ACCESS-KEY：API KEY as a string
-   ACCESS-SIGN：Sign with base64 encoding (see [HMAC](/api-doc/common/signature-samaple/hmac) and [RSA](/api-doc/common/signature-samaple/rsa) sample code).
-   ACCESS-TIMESTAMP：Timestamp of your request. Value equals to milliseconds since Epoch.
-   ACCESS-PASSPHRASE：The password you set when created the API KEY.
-   Content-Type：Please set to application/json for all POST request
-   locale: Support language such as: Chinese (zh-CN), English (en-US)

### How to get ACCESS-TIMESTAMP[​](#how-to-get-access-timestamp "Direct link to How to get ACCESS-TIMESTAMP")

-   Java
-   Python
-   Go
-   JS
-   PHP

Long timestamp = System.currentTimeMillis();

import time  
time.time\_ns() / 1000000

import (  
"time"  
)  
int64(time.Now().UnixNano()/1000000)

Math.round(new Date())

microtime(true) \* 1000;

## Generate Signature[​](#generate-signature "Direct link to Generate Signature")

The request header of ACCESS-SIGN is to encrypt **timestamp + method.toUpperCase() + requestPath + "?" + queryString + body** string (+ means string concat) by **HMAC SHA256** algorithm with **secretKey**. and encode the encrypted result through **BASE64**.

### Description of each parameter in the signature[​](#description-of-each-parameter-in-the-signature "Direct link to Description of each parameter in the signature")

-   timestamp：Same as ACCESS-TIMESTAMP request header. Value equals to milliseconds since Epoch.
-   method：Request method (POST/GET), all uppercase.
-   requestPath：Request interface path.
-   queryString：The query string in the request URL (the request parameter after the ?).
-   body：The request body in string format. If the request body is empty (usually a GET request), the body can be omitted.

**If the queryString is empty, signature content**

`timestamp + method.toUpperCase() + requestPath + body`

**If the queryString not empty, signature content**

`timestamp + method.toUpperCase() + requestPath + "?" + queryString + body`

### Sample Code[​](#sample-code "Direct link to Sample Code")

Get contract depth information, let's take BTCUSDT as an example:

-   timestamp = 16273667805456
-   method = "GET"
-   requestPath = "/api/mix/v2/market/depth"
-   queryString= "?limit=20&symbol=BTCUSDT"

Generate the content to be signed:

`16273667805456GET/api/mix/v2/market/depth?limit=20&symbol=BTCUSDT`

Contract order, take BTCUSDT as an example:

-   timestamp = 16273667805456
-   method = "POST"
-   requestPath = "/api/v2/mix/order/place-order"
-   body = {"productType":"usdt-futures","symbol":"BTCUSDT","size":"8","marginMode":"crossed","side":"buy","orderType":"limit","clientOid":"channel#123456"}

Generate the content to be signed:

`16273667805456POST/api/v2/mix/order/place-order{"productType":"usdt-futures","symbol":"BTCUSDT","size":"8","marginMode":"crossed","side":"buy","orderType":"limit","clientOid":"channel#123456"}`

### Steps to generate the final signature[​](#steps-to-generate-the-final-signature "Direct link to Steps to generate the final signature")

***HMAC***

-   [HMAC sample code](/api-doc/common/signature-samaple/hmac)

Step 1. Use the private key \*\*secretkey\*\* to encrypt the string to be signed with hmac sha256

```
String payload = hmac_sha256(secretkey, Message);
```

Step 2. Base64 encoding for Signature.

```
String signature = base64.encode(payload);
```

***RSA***

-   [RSA sample code](/api-doc/common/signature-samaple/rsa)

Step 1. Use the RSA privateKey **privateKey** to encrypt the string to be signed with SHA-256

Step 2. Base64 encoding for Signature.

> **Source:** https://www.bitget.com/api-doc/common/signature


---

