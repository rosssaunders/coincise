const https = require('https');
const cheerio = require('cheerio');
const fs = require('fs');

// URL of the Deribit API documentation
const url = 'https://docs.deribit.com/';

// Function to categorize endpoints based on name and category
function categorizeEndpoint(endpointName, category) {
  if (category === 'Public Methods' && endpointName.startsWith('public/')) {
    return 'Public WebSocket - Market Data';
  } else if (category === 'Private Methods' && endpointName.startsWith('private/')) {
    if (endpointName.includes('buy') || endpointName.includes('sell') || endpointName.includes('order')) {
      return 'Private WebSocket - Trading';
    } else if (endpointName.includes('position') || endpointName.includes('history') || endpointName.includes('settlement')) {
      return 'Private REST - Post-Trade';
    } else {
      return 'Private REST - Trading'; // Default for private REST trading endpoints
    }
  } else if (category === 'Public Methods' && !endpointName.startsWith('public/')) {
    return 'Public REST - Market Data';
  } else if (category === 'Private Methods' && !endpointName.startsWith('private/')) {
    return 'Private REST - Trading';
  }
  return null; // Fallback for uncategorized endpoints
}

// Fetch the HTML content
https.get(url, (res) => {
  let html = '';
  res.on('data', (chunk) => html += chunk);
  res.on('end', () => {
    const $ = cheerio.load(html);

    // Initialize categorized endpoints object
    const categorizedEndpoints = {
      'Public WebSocket - Market Data': [],
      'Private WebSocket - Trading': [],
      'Public REST - Market Data': [],
      'Private REST - Trading': [],
      'Private REST - Post-Trade': []
    };

    // Find all h2 elements to identify major sections
    const categories = [];
    $('h2').each((i, el) => {
      const categoryText = $(el).text().trim();
      if (categoryText === 'Public Methods' || categoryText === 'Private Methods') {
        categories.push({ name: categoryText, element: el });
      }
    });

    // Extract endpoints under each category
    categories.forEach((cat) => {
      let current = $(cat.element).next();
      while (current.length && current[0].name !== 'h2') {
        if (current[0].name === 'h3') {
          const endpointName = current.text().trim();

          // Extract description (first sentence)
          let description = '';
          let parameters = [];
          let next = current.next();
          while (next.length && next[0].name !== 'h3' && next[0].name !== 'h2') {
            if (next[0].name === 'p') {
              const text = next.text().trim();
              if (text) description += text + ' ';
            } else if (next[0].name === 'ul' || next[0].name === 'table') {
              next.find('li, td:first-child').each((j, item) => {
                const param = $(item).text().trim();
                if (param) parameters.push(param);
              });
            }
            next = next.next();
          }

          // Clean up description and limit to first sentence
          description = description.trim();
          const firstSentence = description.split('.')[0] + (description.includes('.') ? '.' : '');
          
          // Categorize the endpoint
          const endpointCategory = categorizeEndpoint(endpointName, cat.name);
          if (endpointCategory) {
            categorizedEndpoints[endpointCategory].push({
              name: endpointName,
              description: firstSentence,
              parameters: parameters.slice(0, 3) // Limit to top 3 parameters for brevity
            });
          }
        }
        current = current.next();
      }
    });

    // Generate Markdown content
    let markdown = '# Deribit API v2 (Condensed)\n\n';
    markdown += '### Base URLs\n';
    markdown += '- **WebSocket**: wss://www.deribit.com/ws/api/v2\n';
    markdown += '- **REST**: https://www.deribit.com/api/v2\n\n';
    markdown += '### Authentication\n';
    markdown += 'Bearer token via API key\n\n';

    // Add each category and its endpoints
    for (const [cat, endpoints] of Object.entries(categorizedEndpoints)) {
      if (endpoints.length > 0) {
        markdown += `## ${cat}\n\n`;
        endpoints.forEach((ep) => {
          markdown += `- **${ep.name}**\n`;
          markdown += `  - **Description**: ${ep.description || 'No description available.'}\n`;
          if (ep.parameters.length > 0) {
            markdown += `  - **Parameters**: ${ep.parameters.join(', ')}\n`;
          }
        });
        markdown += '\n';
      }
    }

    // Write to file
    fs.writeFileSync('deribit_api_condensed.md', markdown, 'utf8');
    console.log('Condensed Markdown file created: deribit_api_condensed.md');
  });
}).on('error', (err) => {
  console.error('Error fetching documentation:', err);
});